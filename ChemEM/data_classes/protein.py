# This file is part of the ChemEM software.## Copyright (c) 2023 - Topf Group & Leibniz Institute for Virology (LIV),# Hamburg, Germany.## This module was developed by:#   Aaron Sweeney    <aaron.sweeney AT cssb-hamburg.de>from ChemEM.tools.rdtools import RDToolsfrom ChemEM.data_classes.data import BasicDatafrom ChemEM.data_classes.base_classes import Atomfrom rdkit import Chemfrom rdkit.Chem import AllChemfrom rdkit.Geometry import Point3Dfrom collections import Counterimport numpy as npfrom dataclasses import dataclass, fieldimport ctypesimport copyimport time@dataclassclass Protein():    '''    Class for ChemEM Protein representation    '''    protein_file :  str = field(repr = False)    protein_id : str         # openff structure object    openff_structure : object = field(default = None, init = False, repr = False)     residues : list = field(default = None, init = False, repr = False)     num_residues : int = field(default = 0, init = False)        #should be reference to system data!!!    __base_data__ : int = field(repr = False)    #rename this so i can remember which is which        __openff_conversion_keys__ : dict =  field(default = None, init = False, repr = False)    __chemem_conversion_keys__ : dict =  field(default = None, init = False, repr = False)    __residues__ : dict[str, int] =  field(init = False ,repr = False)        system_ligands : list =  field(default_factory=list)            def __iter__(self):        yield from self.residues        @property    def residue_ids(self) -> list[str]:        return list( self.__residues__.keys())        def copy(self):        return copy.deepcopy(self)        def get_residue(self, residue_id):                if '.' in residue_id:            residue_id = residue_id.split('.')[0]                return self.residues[self.__residues__[residue_id]]        def get_atom(self, atom_id):                atom_id = atom_id.split('.')        return self.get_residue(atom_id[0]).get_atom(atom_id[1])        def PDB_from_residue_keys(self, residue_keys, file):         #switch this to using gemmi!! have a look at tmepy conversion!!        _set_first = False        _atom_count = 0        for key in residue_keys:            residue = self.get_residue(key)                        for atom in residue:                if _set_first == False:                    smiles = atom.element                    mol = Chem.MolFromSmiles(smiles)                    AllChem.EmbedMolecule(mol)                    x,y,z = atom.coords                    conf = mol.GetConformer()                    conf.SetAtomPosition(_atom_count, Point3D(round(x, 3), round(y, 3), round(z, 3)))                    mol  =  Chem.RWMol(mol)                    conf = mol.GetConformer()                                        _atom_count += 1                    _set_first = True                else:                    smiles = atom.element                    rd_atom =  Chem.MolFromSmiles(smiles)                    atomic_number = rd_atom.GetAtoms()[0].GetAtomicNum()                    mol.AddAtom(Chem.Atom(atomic_number))                    x,y,z = atom.coords                    conf.SetAtomPosition(_atom_count, Point3D(round(x, 3), round(y, 3), round(z, 3)))                    _atom_count += 1        return mol                def PDB_from_atom_keys(self, residue_keys, file):        pass                def update_positions(self, positions, return_copy = True):                if return_copy == True:            new_protein = self.copy()                else:            new_protein = self                 for key , index in new_protein.__chemem_conversion_keys__.items():            residue = new_protein.get_residue(key)            residue.update_atom_position(key, positions[index])                #update_rd!!        for residue in new_protein:            residue._update_rdmol()            residue.__prot_ref__ = id(new_protein)            if len(residue.aromatic_rings) > 0:                residue.__post_init__                return new_protein        def add_system_ligand(self, ligand):                        residue = Residue(residue_name = ligand.residue_name,                          residue_number = len(self.residues) + 1,                          chain = ligand.chain,                          residue_key = f'{len(self.residues) + 1}:{ligand.chain}',                          __rdmol__ = ligand,                          __prot_ref__ = id(self))                self.__residues__[residue.residue_key] = len(self.__residues__)                ligand_hs = AllChem.AddHs(ligand)        positions = [[i.x,i.y,i.z] for i in ligand.openff_structure.positions]                residue_atoms = []                base_data = BasicData()                atom_counter = Counter()        _atoms = {}        start_pos = len(self.openff_structure.positions)        hn = 0        _openff_conversion = []                for num, (pos, atom) in enumerate(zip(positions, ligand_hs.GetAtoms())):            if atom.GetSymbol() == 'H':                atom_counter.update('H')                key = residue.residue_key + f'.H{atom_counter["H"]}'                    openff_idx = start_pos                _openff_conversion.append([key,openff_idx])                start_pos += 1                continue                        atom_counter.update(atom.GetSymbol())            atom_id = f'{atom.GetSymbol()}{atom_counter[atom.GetSymbol()]}'            key = f'{residue.residue_key}.{atom_id }'            openff_idx = start_pos            start_pos += 1            _openff_conversion.append([key,openff_idx])            _atoms[atom_id] = num            hydrogens = [positions[i.GetIdx()] for i in atom.GetNeighbors() if i.GetSymbol() == 'H']            hydrogens = {f'H{hn + n}': hydro for n, hydro in enumerate(hydrogens)   }            hn += len(hydrogens)                        new_atom = Atom(atom_name = atom_id,                        element = atom.GetSymbol(),                        coords = pos,                        idx = num,                        hydrogens = hydrogens,                        donor_potential = len(hydrogens),                        acceptor_potential = self._get_lone_pair_data(atom.GetSymbol(), base_data))            residue_atoms.append(new_atom)        residue.atoms = residue_atoms        residue.__atoms__ = _atoms        self.residues.append(residue)        self.openff_structure = self.openff_structure + ligand.openff_structure         for key, num in _openff_conversion:           self.__chemem_conversion_keys__[key] = num            self.__openff_conversion_keys__[num] = key        self.system_ligands.append(residue.residue_key)                        def _get_lone_pair_data(self, element, base_data):                try:            lone_pairs = base_data.atom_lone_pair_data[element]            return lone_pairs        except KeyError:            return 0        @dataclassclass Residue():    '''    Class for ChemEM Resiude representation    '''    #not using super from RDKit Mol as it did not work with multiprocessing    residue_name :str    residue_number : int    chain : str    residue_key: str = field(repr = False)    #_residue_key: str = field(repr = False)    atoms : list = field(init = False, repr = False)    aromatic_rings : object = field(default = None, init = False, repr = False)            #dict[ atom name, self.atoms index ]    __atoms__ : dict[str, int] =  field(init = False ,repr = False)    __rdmol__ : object = field(repr = False)    __prot_ref__ : int =  field(repr = False)        def __post_init__(self) -> None:        self.aromatic_rings = RDTools.get_aromatic_rings(self)                #aromatic ring objects!!! from rdtools            def __iter__(self):        yield from self.atoms        @property    def atom_ids(self) -> list[str]:        return list( self.__atoms__.keys())        def get_atom(self, atom_id):        return self.atoms[ self.__atoms__[atom_id] ]        def copy(self):        return copy.deepcopy(self)        def __get_owning_protein__(self):        return ctypes.cast(self.__prot_ref__, ctypes.py_object).value        #exposing rdkit methods to ChemEM residue    def GetBondWithIdx(self, idx):        return self.__rdmol__.GetBondWithIdx(idx)        def GetRingInfo(self):        return self.__rdmol__.GetRingInfo()        def GetConformer(self):        return self.__rdmol__.GetConformer()        def GetAtomWithIdx(self, idx):        return self.__rdmol__.GetAtomWithIdx(idx)        def GetAtoms(self):        return self.__rdmol__GetAtoms()        def update_atom_position(self, key, position, update_rd = False):        key  = key.split('.')[1]                if 'H' in key:            self._update_hydrogen(key, position)        else:            self.get_atom(key).coords = np.array(position)                    if update_rd == True:            self._update_rdmol()             def _update_hydrogen(self,key, position):                for atom in self.atoms:            if key in atom.hydrogens:                atom.hydrogens[key] = position        def _update_rdmol(self):                conf = self.__rdmol__.GetConformer()                 for atom in self:           x,y,z = atom.coords           conf.SetAtomPosition(atom.idx, Point3D(x,y,z))                                                                                             