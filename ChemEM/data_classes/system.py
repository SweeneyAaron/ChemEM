import copyimport numpy as npfrom dataclasses import dataclass, fieldfrom ChemEM.tools.map_tools import MapToolsfrom ChemEM.tools.math import MathToolsdef get_exclude(keys, excluded):    if keys is None:        return None    else:        return [i for i in keys if i not in excluded]@dataclassclass Segment():          segment_id:  str     centroid : list[float]     box_dimensions : list[float]           proteins : dict[str, object] = field(repr=False)    _protein_mols : dict[str, object] = field(repr=False)          ligands : dict[str, object] = field( repr=False)          maps : dict[str, object]  = field(repr=False)    difference_maps : dict[str, object] = field(default_factory = dict, init= False, repr=False)            def make_difference_map(self, proteins = None, maps = None, ligands=None, exclude = None, inc_ligands = False):        #At the moment just using one prot and map need TODO!!!                       proteins = get_exclude(proteins, exclude)        maps = get_exclude(maps, exclude)                if inc_ligands:            ligands = get_exclude(ligands, exclude)           else:            ligands = None                        diff_map, rev_map = MapTools.difference_map(self.maps[maps[0]],                                                        self._protein_mols[proteins[0]],                                                        self.maps[maps[0]].resolution)                diff_map.resolution = self.maps[maps[0]].resolution        diff_map.map_contour = self.maps[maps[0]].map_contour        rev_map.resolution = self.maps[maps[0]].resolution        difference_map = DifferenceMap(proteins = proteins,                                 maps = maps ,                                 ligands = ligands,                                 exclude = exclude,                                 difference_map = diff_map,                                 reverse_map = rev_map)                difference_map_key = f'D{len(self.difference_maps)}'                self.difference_maps[difference_map_key] = difference_map        return difference_map_key     @dataclassclass DifferenceMap():            proteins: list[str]    maps: list[str]    ligands: list[str]    exclude: list[str]        difference_map: object =  field(repr=False)    reverse_map: object = field(repr=False)    density_masks: dict[str, object] = field(default_factory=dict, init=False, repr=False)    centroid: list = field(init = False)        def __post_init__(self):        self.centroid = self.difference_map.get_com()        def write_difference_map(self, path):                self.difference_map.write_to_MRC_file(path)        def write_reverse_map(self, path):        self.reverse_map.write_to_MRC_file(path)        def split_density(self,label_threshold_sigma = None, label_threshold = None , use_reverse = False, threshold = 0.0, struct = None):                """        Split difference map by disconected densities        """                if use_reverse:            densmap = self.reverse_map                else:            densmap = self.difference_map                masked_map, labeled_map, num_features = MapTools.split_density(densmap,                                                                       label_threshold_sigma = label_threshold_sigma,                                                                       label_threshold = label_threshold,                                                                       struct = struct)                density_mask_key = f'X{ len(self.density_masks) }'                self.density_masks[density_mask_key] = Mask(labeled_map  = labeled_map ,                                  num_features = num_features,                                  features = [i+1 for i in range(num_features)])                return density_mask_key        def mask_map(self, density_mask_key, use_reverse = False):                if use_reverse:            densmap = self.reverse_map                else:            densmap = self.difference_map                mask = self.density_masks[density_mask_key].labeled_map.fullMap > 0                densmap.fullMap = densmap.fullMap * mask        self.centroid = densmap.get_com()                       @dataclassclass Mask():    labeled_map : object = field( repr=False)    num_features: int     features: list[int]        def write_mask(self, path):        self.labeled_map.write_to_MRC_file(path)            def keep_labels(self, labels):        #write reverse function!!        if len(labels) > 0:                        mask = self.labeled_map.fullMap == labels[0]                        for l in labels:                mask += self.labeled_map.fullMap == l                self.labeled_map.fullMap = self.labeled_map.fullMap * mask        self.num_features = len(labels)        self.features = [int(i) for i in labels]        def get_closest_label(self, point):                closest_labels = []        for p in point:            min_dist = 9999999999.00            min_label = -1                        for label in self.features:                dist = self._centroid_centroid_dist(label, p)                if dist < min_dist:                    min_dist = dist                    min_label = label                                            closest_labels.append(min_label)                        self.features = closest_labels        self.labeled_map.fullMap = self.labeled_map.fullMap * np.isin(self.labeled_map.fullMap, closest_labels)         self.num_features = len(self.features)            def get_zoned_label(self, point, radius):                zoned_labels = [list() for i in point]        label_dist = []                for num, p in enumerate(point):            for label in self.features:                dist = self._centroid_centroid_dist(label, p)                if dist <= radius:                    zoned_labels[num].append(label)                        self.labeled_map.fullMap = self.labeled_map.fullMap * np.isin(self.labeled_map.fullMap, sum(zoned_labels,[]))         self.num_features = len(sum(zoned_labels, []))        self.features = zoned_labels                        def _centroid_centroid_dist(self, label, point):        points = []        for z in range(self.labeled_map.fullMap.shape[0]):            for y in range(self.labeled_map.fullMap.shape[1]):                for x in range(self.labeled_map.fullMap.shape[2]):                    if self.labeled_map.fullMap[z,y,x] == label:                        points.append(list(self.labeled_map.vectorise_point(x,y,z)))        map_point = MathTools.calc_centroid(points)        dist = MathTools.euclidean_distance(point, map_point)        return dist                                       @dataclassclass ACO():        docking_id : str    protein: object = field(repr=False)    initial_mols : object = field(repr=False)    max_iterations : int = field(init=False)    n_ligands : int     n_atoms : int = field(repr=False)    torsion_lists: list = field(repr=False)    n_torsions : list = field(repr=False)    distance_matrix : object = field(repr=False)    complex_system: object = field(repr=False)    protein_aromatic: list = field(repr=False)    binding_site_radius : float    n_cpus : int     system_data : object = field(repr=False)    all_arrays :np.array =  field(repr=False)    torsion_lists: list = field(repr=False)    pheromone_arrays: np.array = field(init=False, repr=False)    previous_deposits: list = field(init=False, repr=False)    __reset_array__ : np.array = field(init=False, repr=False)    best_since_smoothing : float  = field(default = None, repr=False)    tmax : float = field(default = None, repr=False)    bj_indexes : float = field(init = False, default = None, repr=False)    smoothing_count : int = field(default = 0, repr= False)    last_10 : list = field(init = False, default_factory = list, repr=False)    mi_weight :float = field(default = 50, repr=False)    n_ants : int = field(default = 20, repr=False)    theta : float = field(default = 0.25, repr=False)    rho : float = field(default = 0.15, repr=False)    tmax : float = field(default = 0.0, repr=False)    sigma : float = field(default = 0.5, repr = False)     p_best: list  = field(init = False, default_factory = list, repr=False)    p_best_probs :list  = field(init = False, default_factory = list, repr=False)    t_mins :list  = field(init= False, default_factory = list, repr=False)    _ligand : object = field(default = None, repr=False)    _centroids : object = field(default = None, repr=False)    _dens_map : object = field(default = None, repr=False)    generate_diverse_solutions : int = field(default = False, repr=False)        def __post_init__(self):        self.pheromone_arrays = [[9999 for i in j] for j in self.all_arrays]        self.__reset_array__ = [[9999 for i in j] for j in self.all_arrays]        self.max_iterations = int(self.theta * 10 /self.n_ants * (100 + 50 * sum(self.n_torsions) + 5 * sum(self.n_atoms)))        self.previous_deposits = [[] for i in self.pheromone_arrays]        self.arr_lens = [len(i) for i in self.all_arrays]        def update_best_since_smoothing(self,score):                self.last_10.append(score)        if self.best_since_smoothing is None:            self.best_since_smoothing = score                    elif score > self.best_since_smoothing:            self.best_since_smoothing = score                 def update_tmax(self):                self.tmax = self.best_since_smoothing / self.rho        def update_bj_indexes(self, solution):        self.bj_indexes = [i.index(j) for i, j in zip(self.all_arrays, solution)]            def update_p_best_probs(self):                pb = []        for arr, idx in zip(self.pheromone_arrays, self.bj_indexes):            prob = arr[idx] / sum(arr)            pb.append(prob)        self.p_best_probs = pb        def update_p_best(self):        self.p_best = [sum(self.p_best_probs) for i in self.arr_lens]            def update_tmins(self):        all_tm = []        for prob, a_len in zip(self.p_best, self.arr_lens):            tm = self.tmax * (1 - prob ** (1 / len(self.arr_lens))) / \                (a_len - 1) * prob ** (1 / len(self.arr_lens))            all_tm.append(tm)                self.t_mins = all_tm            def update_pheromones(self, score):        new_phe = []        r = [i for i in range(len(self.pheromone_arrays))]        if score < 0:            score = 0        for num, arr, prev_dep, tmin in zip(r, self.pheromone_arrays, self.previous_deposits, self.t_mins):            new_array = []            if num < 3:                if len(prev_dep) == 0:                    _set = [-1]                else:                    _set = [prev_dep[-1] - 1 %                            len(arr), prev_dep[-1], prev_dep[-1] + 1 % len(arr)]            else:                if len(prev_dep) == 0:                    _set = [-1]                else:                    _set = [prev_dep[-1] - 2 % len(arr), prev_dep[-1] - 1 % len(                        arr), prev_dep[-1], prev_dep[-1] + 1 % len(arr), prev_dep[-1] + 1 % len(arr)]            for n, i in enumerate(arr):                if n in _set:                    Iib = 1                else:                    Iib = 0                tij = (1- self.rho) * i + Iib * score                if tij > self.tmax:                    tij = self.tmax                elif tij < tmin:                    tij = tmin                new_array.append(tij)            new_phe.append(new_array)        self.pheromone_arrays = new_phe        def update_previous_deposits(self):        for num, i in enumerate(self.bj_indexes):            self.previous_deposits[num].append(i)        def do_smoothing(self):        if len(self.last_10) >= 10:            do_smoothing = self.get_do_smoothing()                       if do_smoothing:                if self.smoothing_count == 3:                    self.pheromone_arrays = copy.deepcopy(self.__reset_array__)                    self.smoothing_count = 0                else:                    self.pheromone_arrays = self.get_smoothed_array()                    self.smoothing_count += 1            def get_smoothed_array(self):        new_array = []        for arr in self.pheromone_arrays:            na = []            for t in arr:                nt = t + self.sigma * (self.tmax - t)                na.append(nt)            new_array.append(na)        return new_array        def get_do_smoothing(self):        delta = 0.02 * self.best_since_smoothing        last_10 = self.last_10[-10:]        for i in last_10:            for j in last_10:                if abs(i-j) > delta:                    return False                return True        def _get_ACO_helper_object(self, residue_keys):                        inc_residues = {key : self.protein.get_residue(key) for key in residue_keys}        protein_light= _ProteinLight(inc_residues)        aco_lightweight = ACOHelper(protein = protein_light,                                    initial_mols = self.initial_mols,                                    n_ligands = self.n_ligands,                                    torsion_lists = self.torsion_lists,                                    n_torsions = self.n_torsions,                                    distance_matrix = self.distance_matrix,                                    protein_aromatic = self.protein_aromatic,                                    system_data = self.system_data,                                    mi_weight = self.mi_weight)        return aco_lightweight    @dataclass class _ProteinLight:    residues : dict[str, object] =  field(repr = False)    def get_residue(self, residue_id):            return self.residues[residue_id]        @dataclass class ACOHelper:    protein: object = field(repr=False)    initial_mols : object = field(repr=False)    n_ligands : int     torsion_lists: list = field(repr=False)    n_torsions : list = field(repr=False)    distance_matrix : object = field(repr=False)    protein_aromatic: list = field(repr=False)    system_data : object = field(repr=False)    mi_weight :float = field(default = 50, repr=False)        