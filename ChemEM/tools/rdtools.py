from ChemEM.data_classes.base_classes import Ringfrom rdkit import Chemfrom rdkit.Chem import AllChemfrom rdkit.Chem.rdmolops import AddHsfrom rdkit.Geometry import Point3Dfrom rdkit.Chem import TorsionFingerprints as tfpfrom rdkit.Chem import rdMolTransformsfrom rdkit.Chem import rdmolopsfrom rdkit.Chem import Drawfrom rdkit.Chem.BRICS import BRICSDecomposefrom spyrmsd import rmsd as RMSDimport numpy as npfrom scipy.spatial.transform import Rotation class RDTools():        def BRICS_decomposition(mol, minFragmentSize=3 ):                brics_fragments = BRICSDecompose(mol, minFragmentSize=minFragmentSize)                # brics_fragments = ['OP(=O)(O)O', '[*][C@H]1[C@H]([*])[C@@H](O)[C@@H](O)[C@@H]([*])[C@@H]1O']        frag_dict = {}        for smarts in brics_fragments:            # Convert the fragment SMARTS to a query molecule            frag_query = Chem.MolFromSmarts(smarts)            frag_query = Chem.DeleteSubstructs(frag_query, Chem.MolFromSmarts('[#0]'))                                   if not frag_query:                print(f"Invalid fragment SMARTS: {smarts}")                continue                    matches = mol.GetSubstructMatches(frag_query, useChirality=True)            if not matches:                continue            else:                frag_dict[Chem.MolToSmiles(frag_query)] = matches                return frag_dict            def fragment_file_writter(frag_dict, file_name ):        file = ''        match_idx = 0        for key in frag_dict:            file += f'{key}\n'            matches = frag_dict[key]            for match in matches:                line = f'\tFragment_index: {match_idx}, Atom_idxs: {" ".join([str(i) for i in match] )} \n'                match_idx += 1                file += line               with open(file_name, 'w') as f:            f.write(file)        def draw_molecule_with_atom_indices(mol, file_name):                # Convert the SMILES string to a molecule                # Use RDKit to draw the molecule with atom indices        drawing = Draw.MolDraw2DSVG(400, 400)  # Adjust the size as needed        drawing.drawOptions().addAtomIndices = True  # Show atom indices        drawing.DrawMolecule(mol)        drawing.FinishDrawing()        # Get the SVG data        svg = drawing.GetDrawingText()        # Write the SVG data to a file        with open(file_name, 'w') as f:            f.write(svg)        def save_smiles_with_index(smiles_list, file_name):        mols = []        for smi in smiles_list:            mol = Chem.MolFromSmiles(smi)            if mol is not None:                mols.append(mol)            else:                print(f"Invalid SMILES: {smi}")        # Draw the molecules and save to a file        img = Draw.MolsToGridImage(mols, molsPerRow=3, subImgSize=(200, 200), useSVG=True, legends=[f'{i}' for  i in smiles_list])        with open(file_name, 'w') as f:            f.write(img)        def mol_from_smiles(smiles):        mol_from_smi = Chem.MolFromSmiles(smiles) #add these to there own functions         mol=Chem.AddHs(mol_from_smi)        AllChem.EmbedMolecule(mol)        mol = Chem.RemoveAllHs(mol)        return mol        def mol_from_mol2(mol2_file):        mol = Chem.MolFromMol2File(mol2_file, sanitize=False)        mol = Chem.RemoveHs(mol, sanitize=False)        return mol        def mol_from_sdf(sdf_file, conf_num = 0):        suppl = Chem.SDMolSupplier(sdf_file)        mol = suppl[conf_num]        mol = Chem.RemoveHs(mol, sanitize=False)        return mol       def get_rd_mol(mol_input, input_type):                if input_type == 'smi':            mol = RDTools.mol_from_smiles(mol_input)                    elif input_type == 'sdf':            mol = RDTools.mol_from_sdf(mol_input)                    elif input_type == 'mol2':            mol = RDTools.mol_from_mol2(mol_input)                    return mol        def write_to_sdf( mol,file_name, conf_num=0, removeHs = False):        '''        write 3d mol to sdf file        '''        writer = Chem.SDWriter(file_name)        writer.write(mol, confId=conf_num)        def get_aromatic_rings(molecule):                        aromatic_rings = []                ring_info = molecule.GetRingInfo()        ring_atoms = ring_info.AtomRings()        ring_bonds = ring_info.BondRings()        for atoms, bonds in zip(ring_atoms, ring_bonds):            aromatic = True            for bond_index in bonds:                if not molecule.GetBondWithIdx(bond_index).GetIsAromatic():                    aromatic = False            if aromatic == True:                                positions = molecule.GetConformer().GetPositions()                atom_positions = [positions[i] for i in atoms]                                ring_center = RDTools._get_centroid(atom_positions)                plane_atoms = RDTools._get_plane_atoms(atom_positions)                equation_plane = RDTools._get_equation_plane(plane_atoms)                aromatic_rings.append(Ring(atom_positions = atom_positions,                                           atom_idxs = atoms,                                           ring_center = ring_center,                                           plane = equation_plane))        return aromatic_rings                def _get_equation_plane(atoms):        x1, y1, z1, x2, y2, z2, x3, y3, z3 = atoms[0], atoms[1], atoms[2], atoms[3], atoms[4], atoms[5], atoms[6], atoms[7], atoms[8]        a1 = x2 - x1        b1 = y2 - y1        c1 = z2 - z1        a2 = x3 - x1        b2 = y3 - y1        c2 = z3 - z1        a = b1 * c2 - b2 * c1        b = a2 * c1 - a1 * c2        c = a1 * b2 - b1 * a2        d = (- a * x1 - b * y1 - c * z1)        return (a, b, c, d)    def _get_plane_atoms(ring):        if len(ring) >= 5:            atom_1 = ring[0]            atom_2 = ring[2]            atom_3 = ring[4]        elif len(ring) == 4:            atom_1 = ring[0]            atom_2 = ring[1]            atom_3 = ring[3]        elif len(ring) == 3:            atom_1 = ring[0]            atom_2 = ring[1]            atom_3 = ring[2]        return [atom_1[0], atom_1[1], atom_1[2], atom_2[0], atom_2[1], atom_2[2], atom_3[0], atom_3[1], atom_3[2]]    def _get_centroid(atoms):        x = 0.0        y = 0.0        z = 0.0        n = len(atoms)        for atm in atoms:            x += atm[0]            y += atm[1]            z += atm[2]        x /= n        y /= n        z /= n        return (x, y, z)        def get_mol_hydrogens(mol):        ligand_with_hydrogens = AddHs(mol, addCoords=True)        hydrogen_mol_positions = ligand_with_hydrogens.GetConformer().GetPositions()        mol_positions = mol.GetConformer().GetPositions()        hydrogens = {i:[] for i in range(len(mol_positions))}        for index in hydrogens:            neighbors = ligand_with_hydrogens.GetAtomWithIdx(index).GetNeighbors()            for atom in neighbors:                if atom.GetSymbol() == 'H':                    hydrogens[index].append(hydrogen_mol_positions[atom.GetIdx()])        return hydrogens            def get_mol_centroid(mol, conf_num=0):        '''        get centroid of specific conformer        '''        n = mol.GetNumAtoms()        x = 0.0        y = 0.0        z = 0.0        confs = mol.GetConformers()[conf_num]        atoms = confs.GetPositions()        for atm in atoms:            x += atm[0]            y += atm[1]            z += atm[2]        x /= n        y /= n        z /= n        return (round(x, 3), round(y, 3), round(z, 3))        def translate_mol_to_centroid(mol, centroid):                        mol = RDTools.translate_coords(mol, centroid)        positions = mol.GetConformer().GetPositions()        hydrogens = RDTools.get_mol_hydrogens(mol)        for atom in mol:            atom.coords = positions[atom.idx]            atom.hydrogens = hydrogens[atom.idx]               def translate_point(ori, moved):        x = moved[0] - ori[0]        y = moved[1] - ori[1]        z = moved[2] - ori[2]        return [round(x, 3), round(y, 3), round(z, 3)]    def translate_coords(mol, centroid, n_conf=0):        mol_centroid = RDTools.get_mol_centroid(mol, conf_num=n_conf)        translate = RDTools.translate_point(mol_centroid, centroid)        translated_coords = []        confs = mol.GetConformers()[n_conf]        atoms = confs.GetPositions()        for atm in atoms:            t_x = round(atm[0] + translate[0], 3)            t_y = round(atm[1] + translate[1], 3)            t_z = round(atm[2] + translate[2], 3)            t_xyz = [t_x, t_y, t_z]            translated_coords.append(t_xyz)        translated_coords = np.array(translated_coords)        conf = mol.GetConformers()[n_conf]        for i in range(mol.GetNumAtoms()):            x, y, z = translated_coords[i]            conf.SetAtomPosition(i, Point3D(x, y, z))        return mol        def get_torsion_lists(mol):        '''        Parameters        ----------        mol : TYPE            DESCRIPTION.        Returns        -------        return_torsions : TYPE            DESCRIPTION.        '''        torsion_list = tfp.CalculateTorsionLists(mol)[0]        return_torsions = []        for tor in torsion_list:            tor = tor[0][0]            return_torsions.append(tor)            tor = tor[::-1]            return_torsions.append(tor)  # trying with just one set of torsions                                return return_torsions    def rotate_by_matrix(mol, x, y, z, n_conf = 0):                rotation = Rotation.from_euler('xyz', [x, y, z], degrees=True)        rotation = rotation.as_matrix()        rotation = np.vstack([rotation,[0, 0, 0]])        rotation = np.column_stack([rotation,[0, 0, 0, 1]])        rdMolTransforms.TransformConformer(            mol.GetConformer(n_conf), rotation)        return mol        def dihedral_rotate(mol, index, deg):                        current_angle = rdMolTransforms.GetDihedralDeg(            mol.GetConformer(), index[0], index[1], index[2], index[3])        next_angle = current_angle + float(deg)        rdMolTransforms.SetDihedralDeg(            mol.GetConformer(), index[0], index[1], index[2], index[3], next_angle)        return mol        def get_VDW_radii(atom):        radii_data = {'C':1.9,'N':1.8,'O':1.7,'S':2.0,'P':2.1,'F':1.5,'Cl':1.8,'Br':2.0,'I':2.2, 'MG':0.72, 'NA': 1.02}                return radii_data[atom.GetSymbol()]        def get_VDW_radii_by_symbol(atom):        radii_data = {'C':1.9,'N':1.8,'O':1.7,'S':2.0,'P':2.1,'F':1.5,'Cl':1.8,'Br':2.0,'I':2.2, 'MG':0.72, 'NA': 1.02}                return radii_data[atom]        def rd_mol_hydrogens(mol):        ligand_with_hydrogens = AddHs(mol, addCoords=True)        hydrogen_mol_positions = ligand_with_hydrogens.GetConformer().GetPositions()        mol_positions = mol.GetConformer().GetPositions()        hydrogens = {i:[] for i in range(len(mol_positions))}        for index in hydrogens:            neighbors = ligand_with_hydrogens.GetAtomWithIdx(index).GetNeighbors()            for atom in neighbors:                if atom.GetSymbol() == 'H':                    hydrogens[index].append(hydrogen_mol_positions[atom.GetIdx()])        return hydrogens        def diverse_rmsd(sol1, sol2,):        rmsds = []        for s1,s2 in zip(sol1.refined_solution,sol2.refined_solution):            rmsds.append(RDTools.symm_rmsd(s1, s2))                return np.mean(rmsds)                def symm_rmsd(gt_mol, mol):        atom_pos_gt = gt_mol.GetConformer().GetPositions()        atom_num_gt = [i.GetAtomicNum() for i in gt_mol.GetAtoms()]        adj_gt = rdmolops.GetAdjacencyMatrix(gt_mol)        atom_pos_mol = mol.GetConformer().GetPositions()        atom_num_mol = [i.GetAtomicNum() for i in mol.GetAtoms()]        adj_mol = rdmolops.GetAdjacencyMatrix(mol)        return RMSD.symmrmsd(atom_pos_gt, atom_pos_mol, atom_num_gt, atom_num_mol, adj_gt, adj_mol)