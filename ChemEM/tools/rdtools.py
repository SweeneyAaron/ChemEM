# This file is part of the ChemEM software.## Copyright (c) 2023 - Topf Group & Leibniz Institute for Virology (LIV),# Hamburg, Germany.## This module was developed by:#   Aaron Sweeney    <aaron.sweeney AT cssb-hamburg.de>from ChemEM.data_classes.base_classes import Ringfrom dimorphite_dl import DimorphiteDLimport itertoolsfrom rdkit import Chemfrom rdkit.Chem import AllChemfrom rdkit.Chem.rdmolops import AddHsfrom rdkit.Geometry import Point3Dfrom rdkit.Chem import TorsionFingerprints as tfpfrom rdkit.Chem import rdMolTransformsfrom rdkit.Chem import rdmolopsfrom rdkit.Chem import Drawfrom rdkit.Chem.BRICS import BRICSDecomposefrom rdkit import RDLogger# Suppress RDKit logginglogger = RDLogger.logger()logger.setLevel(RDLogger.CRITICAL)from spyrmsd import rmsd as RMSDimport numpy as npfrom scipy.spatial.transform import Rotation class RDTools():        def get_van_der_waals_radius(element_symbol):        """        Get the van der Waals radius of an element given its symbol using RDKit's PeriodicTable.            Args:        - element_symbol (str): The symbol of the element (e.g., 'C', 'O', 'H').            Returns:        - float: The van der Waals radius in Angstroms.        - None: If the element symbol is not found or van der Waals radius is not available.        """        periodic_table = Chem.GetPeriodicTable()        try:            radius = periodic_table.GetRvdw(element_symbol)            return radius        except ValueError:            print(f"Van der Waals radius for element symbol '{element_symbol}' is not available.")            return 1.8        def generate_possible_protonation_states(protonation_dict):        """        Generate all possible protonation states for a molecule.                Parameters:        protonation_dict (dict): A dictionary where keys are atom indexes and values are lists of possible protonation states.                Returns:        list: A list of dictionaries representing all possible combinations of protonation states.        """        keys = protonation_dict.keys()        values = protonation_dict.values()                # Generate all possible combinations of protonation states        combinations = list(itertools.product(*values))                # Create a list of dictionaries for each combination        all_states = []        for combination in combinations:            state_dict = dict(zip(keys, combination))            all_states.append(state_dict)                return all_states                    def get_assigned_atom_indices(mol,match, atom_data):                indices = []        for idx in match:            atom = mol.GetAtomWithIdx(idx)            if atom.GetSymbol() == atom_data[0]:                neighbors = sorted([i.GetSymbol() for i in atom.GetNeighbors()])                if neighbors == sorted(atom_data[1]):                    indices.append(idx)                return indices    def protonate(smi, pH = [6.4, 8.4], n = 1.0):                dimorphite_dl = DimorphiteDL(            min_ph=pH[0],            max_ph=pH[1],            max_variants=128,            label_states=False,            pka_precision=n        )                protonate_smiles = dimorphite_dl.protonate(smi)                middle_ph = sum(pH) / 2                dimorphite_dl_at_ph = DimorphiteDL(            min_ph=middle_ph,            max_ph=middle_ph,            max_variants=128,            label_states=False,            pka_precision=0.0        )        most_probable = dimorphite_dl_at_ph.protonate(smi)                       #checks        display_message = False        if most_probable and protonate_smiles:            return_smi = [most_probable[0]] + [i for i in protonate_smiles if i not in [most_probable[0]]]            display_message = True        elif protonate_smiles:            return_smi = protonate_smiles            display_message = True                else:            return_smi = [smi]                if display_message:            if len(return_smi) == 1:                print(f'Continuing with ligand smiles: {return_smi[0]}')                                        elif len(return_smi) > 1:                print(f'Multiple Protonation states found for molecule {smi} :')                for s in return_smi:                    print(f'\t{s} \n')                                print(f'Continuing calculations with first entry: \n\t{return_smi[0]}')                print('\nTo specify a protonation state apply chemem.Protonation on your conf file.')                print('To disable protonation set "protonation = 0" in your configuration file.')                print('See documentation for further details (https://chemem.topf-group.com/)')                                                return return_smi            def BRICS_decomposition(mol, minFragmentSize=3 ):                _ = Chem.GetSymmSSSR(mol)  # This initializes ring info        brics_fragments = BRICSDecompose(mol, minFragmentSize=minFragmentSize)                frag_dict = {}        for smarts in brics_fragments:            # Convert the fragment SMARTS to a query molecule            frag_query = Chem.MolFromSmarts(smarts)            frag_query = Chem.DeleteSubstructs(frag_query, Chem.MolFromSmarts('[#0]'))                                   if not frag_query:                #TODO! more elegant handling of this!!                #print(f"Invalid fragment SMARTS: {smarts}")                continue                    matches = mol.GetSubstructMatches(frag_query, useChirality=True)            if not matches:                continue            else:                frag_dict[Chem.MolToSmiles(frag_query)] = matches        mol.fragment_dict = frag_dict                    def fragment_file_writter(mol, file_name):                frag_dict = mol.fragment_dict        file = ''        match_idx = 0        fragment_idx_to_atoms = {}        for key in frag_dict:            file += f'{key}\n'            matches = frag_dict[key]            for match in matches:                line = f'\tFragment_index: {match_idx}, Atom_key: {mol.residue_name}:{".".join([str(i) for i in match] )} \n'                fragment_idx_to_atoms[match_idx] = [i for i in match]                match_idx += 1                file += line                mol.fragment_idx_to_atoms = fragment_idx_to_atoms                with open(file_name, 'w') as f:            f.write(file)        def draw_molecule_with_atom_indices(mol, file_name):                # Convert the SMILES string to a molecule                # Use RDKit to draw the molecule with atom indices        drawing = Draw.MolDraw2DSVG(400, 400)  # Adjust the size as needed        drawing.drawOptions().addAtomIndices = True  # Show atom indices        drawing.DrawMolecule(mol)        drawing.FinishDrawing()        # Get the SVG data        svg = drawing.GetDrawingText()        # Write the SVG data to a file        with open(file_name, 'w') as f:            f.write(svg)        def save_smiles_with_index(mol, file_name):        smiles_list = mol.fragment_dict.keys()        mols = []        for smi in smiles_list:            frag_mol = Chem.MolFromSmiles(smi)            if frag_mol is not None:                mols.append(frag_mol)            else:                continue                #TODO! handle None                #print(f"Invalid SMILES: {smi}")        # Draw the molecules and save to a file        img = Draw.MolsToGridImage(mols, molsPerRow=3, subImgSize=(200, 200), useSVG=True, legends=[f'{i}' for  i in smiles_list])        with open(file_name, 'w') as f:            f.write(img)        def mol_from_smiles(smiles,                         protonation = True,                        pH=[6.4,7.4],                        n = 1.0):        smiles = Chem.CanonSmiles(smiles)        if protonation:            try:                smiles = RDTools.protonate(smiles,pH=pH, n=n)                smiles = smiles[0]            except Exception as e:                print(f'ChemEM - Warning: Failed to protonate mol {smiles}. \nFull Error: {e}')                mol_from_smi = Chem.MolFromSmiles(smiles) #add these to there own functions         mol= AddHs(mol_from_smi, addCoords=True)        AllChem.EmbedMolecule(mol)        mol = Chem.RemoveAllHs(mol)        return mol        def mol_from_pdb(pdb_file,sanitize = False):        mol = Chem.MolFromPDBFile(pdb_file)        mol = Chem.RemoveHs(mol, sanitize=sanitize)        return mol        def mol_from_mol2(mol2_file):        mol = Chem.MolFromMol2File(mol2_file, sanitize=False)        mol = Chem.RemoveHs(mol, sanitize=False)        return mol        def mol_from_sdf(sdf_file, conf_num = 0):        suppl = Chem.SDMolSupplier(sdf_file)        mol = suppl[conf_num]        mol = Chem.RemoveHs(mol, sanitize=False)        return mol    def get_rd_mol(mol_input, input_type,                    protonation = True,                   chirality = True,                   rings = True,                   pH=[6.4,8.4],                   n=1.0):                if input_type == 'smi':            mol = RDTools.mol_from_smiles(mol_input,                                           protonation=protonation,                                          pH=pH,                                          n=n)                    elif input_type == 'sdf':            mol = RDTools.mol_from_sdf(mol_input)                    elif input_type == 'mol2':            mol = RDTools.mol_from_mol2(mol_input)                if mol is None:            return mol                if chirality:            RDTools.check_unassigned_chirality(mol)                        if rings:            try:                            _ = Chem.GetSymmSSSR(mol)  # This initializes ring info            except Exception as e:                print(f'ChemEM- Non-Fatal warning ring info assignment failed with GetSymmSSSR.\nFull Error: {e}')                return mol        def check_unassigned_chirality(mol):        '''                Checks molecules for unassigned chirality,         attempts to assign chirality from structure if unassigned.        Parameters        ----------        mol : mol (rdkit.Chem.Mol)                    Returns        -------        None.        '''                chiral_centers = Chem.FindMolChiralCenters(mol, includeUnassigned=True)                unassigned_chirality = [i for i in chiral_centers if i[1] == '?']        if unassigned_chirality:            #TODO! --move to messages            print('ChemEM - Warning: Unassigned chirality found in moleucle assigning chirality from structure')            print(f'\tMolecule Chirality (atom_idx, "S"|"R"|"?") : {chiral_centers}')            try:                Chem.AssignAtomChiralTagsFromStructure(mol)                chiral_centers = Chem.FindMolChiralCenters(mol, includeUnassigned=True)                print(f'\tNew Molecule Chirality (atom_idx, "S"|"R"|"?") : {chiral_centers}')            except Exception as e:                print(f'Unable to assign chirality from structure failed with error: \n\t {e}')                print('Attempting to load ligand with unassigned chirality.')                    def write_to_sdf( mol,file_name, conf_num=0, removeHs = False):        '''        write 3d mol to sdf file        Parameters        ----------        mol : mol (rdkit.Chem.Mol)        file_name : str            Output file        conf_num : int, optional            conformation_number. The default is 0.        removeHs : bool, optional            whether to remove hydrogens when writting. The default is False.        Returns        -------rt        None.        '''        writer = Chem.SDWriter(file_name)        writer.write(mol, confId=conf_num)        def get_aromatic_rings(molecule):                        aromatic_rings = []                ring_info = molecule.GetRingInfo()        ring_atoms = ring_info.AtomRings()        ring_bonds = ring_info.BondRings()        for atoms, bonds in zip(ring_atoms, ring_bonds):            aromatic = True            for bond_index in bonds:                if not molecule.GetBondWithIdx(bond_index).GetIsAromatic():                    aromatic = False            if aromatic == True:                                positions = molecule.GetConformer().GetPositions()                atom_positions = [positions[i] for i in atoms]                                ring_center = RDTools._get_centroid(atom_positions)                plane_atoms = RDTools._get_plane_atoms(atom_positions)                equation_plane = RDTools._get_equation_plane(plane_atoms)                aromatic_rings.append(Ring(atom_positions = atom_positions,                                           atom_idxs = atoms,                                           ring_center = ring_center,                                           plane = equation_plane))        return aromatic_rings                def _get_equation_plane(atoms):        x1, y1, z1, x2, y2, z2, x3, y3, z3 = atoms[0], atoms[1], atoms[2], atoms[3], atoms[4], atoms[5], atoms[6], atoms[7], atoms[8]        a1 = x2 - x1        b1 = y2 - y1        c1 = z2 - z1        a2 = x3 - x1        b2 = y3 - y1        c2 = z3 - z1        a = b1 * c2 - b2 * c1        b = a2 * c1 - a1 * c2        c = a1 * b2 - b1 * a2        d = (- a * x1 - b * y1 - c * z1)        return (a, b, c, d)    def _get_plane_atoms(ring):        if len(ring) >= 5:            atom_1 = ring[0]            atom_2 = ring[2]            atom_3 = ring[4]        elif len(ring) == 4:            atom_1 = ring[0]            atom_2 = ring[1]            atom_3 = ring[3]        elif len(ring) == 3:            atom_1 = ring[0]            atom_2 = ring[1]            atom_3 = ring[2]        return [atom_1[0], atom_1[1], atom_1[2], atom_2[0], atom_2[1], atom_2[2], atom_3[0], atom_3[1], atom_3[2]]    def _get_centroid(atoms):        x = 0.0        y = 0.0        z = 0.0        n = len(atoms)        for atm in atoms:            x += atm[0]            y += atm[1]            z += atm[2]        x /= n        y /= n        z /= n        return (x, y, z)        def get_mol_hydrogens(mol):        ligand_with_hydrogens = AddHs(mol, addCoords=True)        hydrogen_mol_positions = ligand_with_hydrogens.GetConformer().GetPositions()        mol_positions = mol.GetConformer().GetPositions()        hydrogens = {i:[] for i in range(len(mol_positions))}        for index in hydrogens:            neighbors = ligand_with_hydrogens.GetAtomWithIdx(index).GetNeighbors()            for atom in neighbors:                if atom.GetSymbol() == 'H':                    hydrogens[index].append(hydrogen_mol_positions[atom.GetIdx()])        return hydrogens            def get_mol_centroid(mol, conf_num=0):        '''        get centroid of specific conformer        '''        n = mol.GetNumAtoms()        x = 0.0        y = 0.0        z = 0.0        confs = mol.GetConformers()[conf_num]        atoms = confs.GetPositions()        for atm in atoms:            x += atm[0]            y += atm[1]            z += atm[2]        x /= n        y /= n        z /= n        return (round(x, 3), round(y, 3), round(z, 3))        def translate_mol_to_centroid(mol, centroid):                        mol = RDTools.translate_coords(mol, centroid)        positions = mol.GetConformer().GetPositions()        hydrogens = RDTools.get_mol_hydrogens(mol)        for atom in mol:            atom.coords = positions[atom.idx]            atom.hydrogens = hydrogens[atom.idx]               def translate_point(ori, moved):        x = moved[0] - ori[0]        y = moved[1] - ori[1]        z = moved[2] - ori[2]        return [round(x, 3), round(y, 3), round(z, 3)]    def translate_coords(mol, centroid, n_conf=0):        mol_centroid = RDTools.get_mol_centroid(mol, conf_num=n_conf)        translate = RDTools.translate_point(mol_centroid, centroid)        translated_coords = []        confs = mol.GetConformers()[n_conf]        atoms = confs.GetPositions()        for atm in atoms:            t_x = round(atm[0] + translate[0], 3)            t_y = round(atm[1] + translate[1], 3)            t_z = round(atm[2] + translate[2], 3)            t_xyz = [t_x, t_y, t_z]            translated_coords.append(t_xyz)        translated_coords = np.array(translated_coords)        conf = mol.GetConformers()[n_conf]        for i in range(mol.GetNumAtoms()):            x, y, z = translated_coords[i]            conf.SetAtomPosition(i, Point3D(x, y, z))        return mol        def get_torsion_lists(mol):        '''        Parameters        ----------        mol : TYPE            DESCRIPTION.        Returns        -------        return_torsions : TYPE            DESCRIPTION.        '''        torsion_list = tfp.CalculateTorsionLists(mol)[0]        return_torsions = []        for tor in torsion_list:            tor = tor[0][0]            return_torsions.append(tor)            tor = tor[::-1]            return_torsions.append(tor)  # trying with just one set of torsions                                 return return_torsions    def rotate_by_matrix(mol, x, y, z, n_conf = 0):                rotation = Rotation.from_euler('xyz', [x, y, z], degrees=True)        rotation = rotation.as_matrix()        rotation = np.vstack([rotation,[0, 0, 0]])        rotation = np.column_stack([rotation,[0, 0, 0, 1]])        rdMolTransforms.TransformConformer(            mol.GetConformer(n_conf), rotation)        return mol        def dihedral_rotate(mol, index, deg):                        current_angle = rdMolTransforms.GetDihedralDeg(            mol.GetConformer(), index[0], index[1], index[2], index[3])        next_angle = current_angle + float(deg)        rdMolTransforms.SetDihedralDeg(            mol.GetConformer(), index[0], index[1], index[2], index[3], next_angle)        return mol        def get_VDW_radii(atom):        radii_data = {'C':1.9,'N':1.8,'O':1.7,'S':2.0,'P':2.1,'F':1.5,'Cl':1.8,'Br':2.0,'I':2.2, 'MG':0.72, 'NA': 1.02}                return radii_data[atom.GetSymbol()]        def get_VDW_radii_by_symbol(atom):        radii_data = {'C':1.9,'N':1.8,'O':1.7,'S':2.0,'P':2.1,'F':1.5,'Cl':1.8,'Br':2.0,'I':2.2, 'MG':0.72, 'NA': 1.02}                return radii_data[atom]        def rd_mol_hydrogens(mol):        ligand_with_hydrogens = AddHs(mol, addCoords=True)        hydrogen_mol_positions = ligand_with_hydrogens.GetConformer().GetPositions()        mol_positions = mol.GetConformer().GetPositions()        hydrogens = {i:[] for i in range(len(mol_positions))}        for index in hydrogens:            neighbors = ligand_with_hydrogens.GetAtomWithIdx(index).GetNeighbors()            for atom in neighbors:                if atom.GetSymbol() == 'H':                    hydrogens[index].append(hydrogen_mol_positions[atom.GetIdx()])        return hydrogens        def diverse_rmsd(sol1, sol2,):        rmsds = []        for s1,s2 in zip(sol1.refined_solution,sol2.refined_solution):            rmsds.append(RDTools.symm_rmsd(s1, s2))                return np.mean(rmsds)                def symm_rmsd(gt_mol, mol):        atom_pos_gt = gt_mol.GetConformer().GetPositions()        atom_num_gt = [i.GetAtomicNum() for i in gt_mol.GetAtoms()]        adj_gt = rdmolops.GetAdjacencyMatrix(gt_mol)        atom_pos_mol = mol.GetConformer().GetPositions()        atom_num_mol = [i.GetAtomicNum() for i in mol.GetAtoms()]        adj_mol = rdmolops.GetAdjacencyMatrix(mol)        return RMSD.symmrmsd(atom_pos_gt, atom_pos_mol, atom_num_gt, atom_num_mol, adj_gt, adj_mol)