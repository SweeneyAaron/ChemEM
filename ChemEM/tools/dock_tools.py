import sysfrom time import perf_counterimport numpy as npimport scipyfrom pathos.pools import ProcessPoolimport os import copyfrom ChemEM.tools.rdtools import RDToolsfrom ChemEM.scoring_functions import ScoringFunctionsfrom ChemEM.tools.openff_tools import OpenFFTools from rdkit import Chemfrom rdkit.Chem.rdmolops import AddHsfrom dataclasses import dataclass, fieldfrom time import perf_counter@dataclassclass Solution:    iteration : int     chemem_solution : object = field(repr = False)    chemem_score : float     refined_solution : object = field(repr = False)    refined_score : float    protein_positions : object  = field(repr = False)        def __str__(self):        return f'Iteration {self.iteration}: \n\tchemem score - {self.chemem_score} \n\trefined score - {self.refined_score}'        def write_chemem_solution(self, outpath):        if len(self.chemem_solution) == 1:            file_name = f'Ligand_{self.iteration}_chemem.sdf'            write_path = os.path.join(outpath , file_name)            RDTools.write_to_sdf(self.chemem_solution[0], write_path)        else:            for num,sol in enumerate(self.chemem_solution):                file_name = f'Ligand_{self.iteration}_{num}_chemem.sdf'                write_path = os.path.join(outpath , file_name)                RDTools.write_to_sdf(sol, write_path)                        def write_refined_solution(self, outpath):        if len(self.refined_solution) == 1:            file_name = f'Ligand_{self.iteration}_refined.sdf'            write_path = os.path.join(outpath , file_name)            RDTools.write_to_sdf(self.refined_solution[0], write_path)        else:            for num,sol in enumerate(self.refined_solution):                file_name = f'Ligand_{self.iteration}_{num}_refined.sdf'                write_path = os.path.join(outpath , file_name)                RDTools.write_to_sdf(sol, write_path)                    def write_pdb(self, outpath):        file_name = f'Ligand_{self.iteration}_refined_complex.pdb'        write_path = os.join(outpath , file_name)        #Finish!!!                            class DockTools():    def copy_map(densmap):        if densmap is None:            return None        else:                        return densmap.copy()            def ACO(ACO_object, difference_map = None):                print(f'Docking {ACO_object.n_ligands} ligands with {ACO_object.max_iterations} iterations...')                        pool = ProcessPool(nodes=ACO_object.n_cpus)            ACO_object.best_solutions = []        residue_keys = [key for key in ACO_object.distance_matrix.position_keys if not key.startswith('L')]        residue_keys = [i.split('.')[0] for i in residue_keys]        residue_keys += [key for key in ACO_object.protein_aromatic]        residue_keys = list(set(residue_keys))        residue_keys = {key : ACO_object.protein.get_residue(key) for key in residue_keys}        for iteration in range(ACO_object.max_iterations):                    t1 = perf_counter()            ant_mols = []            ant_scores = []            ant_solutions = []            for n_ant in range(ACO_object.n_ants):                                solution = DockTools.construct_solution(ACO_object.all_arrays,                                                         ACO_object.pheromone_arrays)                                mols = DockTools.mols_from_solutions(solution, ACO_object)                                                score = ScoringFunctions.ChemEM_score(mols, ACO_object, difference_map = difference_map)                               ant_mols.append(mols)                ant_scores.append(score)                ant_solutions.append(solution)                                        aco_lightweight = ACO_object._get_ACO_helper_object(residue_keys)            local_minimiser_paramters = []            for solution in ant_solutions:                local_minimiser_paramters.append([solution, copy.deepcopy(aco_lightweight), DockTools.copy_map(difference_map)])              results = pool.map(DockTools.neadler_mead_mutltiproc, local_minimiser_paramters)                        max_index = results.index(max(results, key=lambda x: x[0]))            max_score, max_mol, max_solution = results[max_index]                                    openff_mol, openff_positions = OpenFFTools.openff_minimiser(max_mol, ACO_object)            openff_score = ScoringFunctions.ChemEM_score(openff_mol, ACO_object, difference_map = difference_map)            t2 = perf_counter() - t1                        print(f'\rIteration {iteration}, Score : {round(openff_score, 4)}, Runtime: {round( (t2 / 60), 2)} min', sep='', end='', flush=True )                                                #  solution for optimisation            ant_solution = ant_solutions[max_index]                           #check here            ACO_object.update_best_since_smoothing(max_score)            ACO_object.update_tmax()            ACO_object.update_bj_indexes(ant_solution)            ACO_object.update_p_best_probs()            ACO_object.update_p_best()            ACO_object.update_tmins()            #check here            ACO_object.update_pheromones(max_score)            ACO_object.update_previous_deposits()            solution = Solution(iteration= iteration,                      chemem_solution = max_mol,                      chemem_score = max_score,                      refined_solution = openff_mol,                      refined_score = openff_score,                      protein_positions = openff_positions)            ACO_object.best_solutions.append(solution)            ACO_object.do_smoothing()                    ACO_object.best_solutions = sorted(ACO_object.best_solutions, key=lambda x: x.refined_score, reverse=True)                               def get_smoothed_array(pheromone_arr, sigma, tmax):        new_array = []        for arr in pheromone_arr:            na = []            for t in arr:                nt = t + sigma * (tmax - t)                na.append(nt)        return new_array        def get_do_smoothing(best_since_smoothing, last_10):        delta = 0.02 * best_since_smoothing        last_10 = last_10[-10:]        for i in last_10:            for j in last_10:                if abs(i-j) > delta:                    return False        return True            def get_tmins(probs, problem_dimension, tmax, arr_lens):        all_tm = []        for prob, a_len in zip(probs, arr_lens):            tm = tmax * (1 - prob ** (1 / problem_dimension)) / \                (a_len - 1) * prob ** (1 / problem_dimension)            all_tm.append(tm)        return all_tm        def get_p_best_probs(phe_arr, tmax, solution_idxs):        pb = []        for arr, idx in zip(phe_arr, solution_idxs):            prob = arr[idx] / sum(arr)            pb.append(prob)        return pb        def neadler_mead_mutltiproc(args):                        solution, ACO_object, difference_map = args        new_score, new_mol, new_solution = DockTools.neadler_mead_local_search(solution, ACO_object, difference_map)        return new_score, new_mol, new_solution            def neadler_mead_local_search(solution,                                  ACO_object,                                  difference_map,                                  _tol=1e0 #1e0                                  ):        solution_delta = []        bounds =[]        for n_tor in ACO_object.n_torsions:            solution_delta  += [0.5,0.5,0.5,0.5,0.5,0.5] + [0.5 for i in range(n_tor)]            #solution_delta += [2.0, 2.0, 2.0, 90.0, 90.0, 90.0] + [90.0 for i in range(n_tor)]            bounds += [(0.0, 1.0), (0.0, 1.0), (0.0, 1.0), (0.0, 1.0), (0.0, 1.0),(0.0, 1.0)] + [(0.0, 1.0) for i in range(n_tor)]                                result = scipy.optimize.minimize(DockTools.__chem_em_neadler_mead_wrapper__,                                 solution_delta,                                args = (solution, ACO_object, difference_map ),                                method='Nelder-Mead',                                 tol=_tol,                                bounds=bounds,                                #options={'fatol' : 1e-1, 'xatol' : 1e-1}                                )                                new_score, new_mol, new_solution = DockTools.__chem_em_neadler_mead_wrapper__(result.x,                                                                             solution,                                                                            ACO_object,                                                                            difference_map,                                                                            return_score_only = False)                                                                                                                                               return new_score, new_mol, new_solution                    def __chem_em_neadler_mead_wrapper__(delta_solution,                                          solution,                                         ACO_object,                                         difference_map,                                         return_score_only = True):        _sol = solution.copy()        new_solution = DockTools.convert_params(solution, ACO_object.n_torsions, delta_solution )                        #new_solution = [i + j for i,j in zip(solution,delta_solution)]        #needs to be within bounds!!        mols = DockTools.mols_from_solutions(new_solution, ACO_object)        if return_score_only:            return ScoringFunctions.ChemEM_score(mols, ACO_object, difference_map = difference_map) * -100        else:            return ScoringFunctions.ChemEM_score(mols, ACO_object, difference_map = difference_map), mols, new_solution                def convert_params(molecule_params, rotatable_bonds, normalized_values):        converted_params = []        idx = 0        for n_bonds in rotatable_bonds:            # 6 parameters for distance/rotation, then n_bonds parameters for bond rotations            for _ in range(6 + n_bonds):                value = normalized_values[idx]                ini_value = molecule_params[idx]                if _ < 3:  # This is a distance                    converted_value = DockTools.convert_distance(value,ini_value)                else:  # This is a rotation parameter                    converted_value = DockTools.convert_rotation(value, ini_value)                converted_params.append(converted_value)                idx += 1        return converted_params        def convert_distance(value, ini_value):                expanded_value = round(value * 4.0 - 2.0, 3)        new_value = ini_value + expanded_value        return new_value        def convert_rotation(value, ini_value):        expanded_value = value  * 360 - 180        new_value = ini_value + expanded_value        new_value = round(new_value % 360, 3)                return new_value         def convert_rotation_old(value, ini_value):        expanded_value = value  * 360        new_value = ini_value + expanded_value        new_value = round(new_value % 360, 3)                return new_value                 def apply_solution(solution, mol, torsion_indexes):                solution = [round(i,3) for i in solution]                mol_copy =   Chem.Mol(mol)                centroid = solution[:3]        rotations = solution[3:6]        torsion_angles = solution[6:]                RDTools.rotate_by_matrix(mol_copy, rotations[0],rotations[1],rotations[2])        for index,deg in zip(torsion_indexes, torsion_angles):            RDTools.dihedral_rotate(mol_copy, index, deg)                RDTools.translate_coords(mol_copy,centroid)        return mol_copy        def mols_from_solutions(solution, ACO_object):                mols = []        tor_count = 0        for idx in range(ACO_object.n_ligands):            n_tor = 6 + ACO_object.n_torsions[idx]            sol = solution[tor_count: tor_count + n_tor]            mols.append(DockTools.apply_solution(sol, ACO_object.initial_mols[idx], ACO_object.torsion_lists[idx]))            tor_count += n_tor                return mols                            def construct_solution(all_arrays, pheromone_arrays):        solution = []                for arr,phe_arr in zip(all_arrays,pheromone_arrays):            choice = DockTools.make_choice(phe_arr)            solution.append(arr[choice])        return solution        def get_probability_array(phe_arr):        probability_array = []        p_sum = sum(phe_arr)                for num, i in enumerate(phe_arr):            prob = i / p_sum            probability_array.append((prob,num))        probability_array = sorted(probability_array, key = lambda x: x[0], reverse = True)                return probability_array        def roulette_wheel(prob_array):                cumulative_array = []        for num in range(len(prob_array)):            cumulative_array.append(round(sum([i[0] for i in prob_array[num:]]), 3))                rou = round(np.random.uniform(0,1.0), 3)        if rou <= cumulative_array[-1]:            return prob_array[-1][1]        for num in range(len(cumulative_array[:-1])):                        if rou <= cumulative_array[num]  and rou > cumulative_array[num + 1]:                return prob_array[num][1]        def make_choice(pheromone_array):                prob_arr = DockTools.get_probability_array(pheromone_array)        choice = DockTools.roulette_wheel(prob_arr)        return choice