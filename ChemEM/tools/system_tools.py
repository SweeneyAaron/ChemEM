# This file is part of the ChemEM software.## Copyright (c) 2023 - Topf Group & Leibniz Institute for Virology (LIV),# Hamburg, Germany.## This module was developed by:#   Aaron Sweeney    <aaron.sweeney AT cssb-hamburg.de>import numpy as npimport multiprocessingimport tempfileimport osfrom ChemEM.tools.protein_tools import ProteinToolsfrom ChemEM.tools.openff_tools import OpenFFToolsfrom ChemEM.tools.map_tools import MapToolsfrom ChemEM.data_classes.system import Segment, ACOfrom ChemEM.data_classes.base_classes import DistanceMatrixfrom rdkit import Chemfrom scipy.spatial import distance_matrixfrom scipy.spatial import cKDTreefrom Bio.PDB import PDBParserfrom Bio.PDB.SASA import ShrakeRupleyclass SystemTools():            def _update_system_data_ids(system):                system_data_id = id(system.system_data)        for protein in system.proteins.values():            protein.__base_data__ = system_data_id        def _update_protein_ids(system):        for protein in system.proteins.values():            protein_id = id(protein)            for residue in protein.residues:                residue.__prot_ref__ = protein_id        def segment_system(system, centroid = None, box_dimensions = None, exclude = None):                if centroid is None:            centroid = system.centroid         if box_dimensions is None:            box_dimensions = system.segment_dimensions                segment_limits = SystemTools.get_segment_limits(centroid, box_dimensions)        segment_proteins = []        segment_protein_mols = []        segment_maps = []        segment_ligands = []                for protein in system.proteins:            #pick one!!!            segment_residues, segment_atoms = ProteinTools.get_protein_segment(segment_limits, protein)                        if len(segment_residues) == 0:                continue                        segment_mol = ProteinTools.rd_mol_from_residue_keys(protein,  segment_residues)                                    segment_proteins.append(segment_residues)            segment_protein_mols.append(segment_mol)                    #add segment mols togheter!!!TODO!        #add ligands!!!TODO!        #add maps togheter!! normalise first!!                #can only use one map at the moment!!                for densmap in system.maps:                        segment_map = MapTools.get_map_segement(densmap, segment_limits)            segment_maps.append(segment_map)                            segment_id = f'S{system.system_id}'                        return segment_id, Segment(segment_id = segment_id,                       centroid = centroid,                       box_dimensions = box_dimensions,                       proteins = segment_proteins,                       _protein_mols = segment_protein_mols,                       ligands = segment_ligands,                       maps = segment_maps)                            def get_segment_limits(centroids, limits):                max_x, max_y, max_z = -9999999, -999999, -9999999        min_x, min_y, min_z = 999999, 999999, 999999        for centroid in centroids:            x,y,z = centroid            if x > max_x:                max_x = x            if x < min_x:                min_x = x                        if y > max_y:                max_y = y            if y < min_y:                min_y = y                        if z > max_z:                max_z = z            if z < min_z:                min_z = z                min_x -= (limits[0]/2)        min_y -= (limits[1]/2) # changed this !!!        min_z -= (limits[2]/2)                max_x += (limits[0]/2)        max_y += (limits[1]/2)        max_z += (limits[2]/2)                box_lim = [min_x, max_x, min_y, max_y, min_z, max_z]                                return box_lim                def get_vdw_radius(element_symbol):        periodic_table = Chem.GetPeriodicTable()        return periodic_table.GetRvdw(element_symbol)        def set_excluded_indices_old(indices, protein, residue_ids, box_limits):        indices_for_exclusion = []        for ind in indices:            if  ind[0] < box_limits[0] and ind[0] > box_limits[0]:                continue            if  ind[1] < box_limits[1] and ind[1] > box_limits[1]:                continue            if  ind[2] < box_limits[2] and ind[2] > box_limits[2]:                continue            indices_for_exclusion.append(np.array(ind))        indices_for_exclusion = np.array(indices_for_exclusion)        protein_atom_positions = []        protein_atom_radii = []        for res_id in residue_ids:            residue = protein.get_residue(res_id)            for atom in residue.atoms:                protein_atom_positions.append(atom.coords)                protein_atom_radii.append(SystemTools.get_vdw_radius(atom.element))        protein_atom_positions = np.array(protein_atom_positions)        protein_atom_radii = np.array(protein_atom_radii)                        dist_matrix = distance_matrix(protein_atom_positions, indices_for_exclusion)        import pdb         pdb.set_trace()        is_inside_matrix = dist_matrix <= protein_atom_radii        points_inside_mask = np.all(is_inside_matrix, axis=1)        if True in points_inside_mask:            import pdb            pdb.set_trace()            return True         else:            return False            def set_excluded_indices(indices, protein, residue_ids, box_limits, radius = 2.0):        indices_for_exclusion = []        for ind in indices:            if  ind[0] < box_limits[0] and ind[0] > box_limits[0]:                continue            if  ind[1] < box_limits[1] and ind[1] > box_limits[1]:                continue            if  ind[2] < box_limits[2] and ind[2] > box_limits[2]:                continue            indices_for_exclusion.append(np.array(ind))        indices_for_exclusion = np.array(indices_for_exclusion)        protein_atom_positions = []        for res_id in residue_ids:            residue = protein.get_residue(res_id)            for atom in residue.atoms:                protein_atom_positions.append(atom.coords)        protein_atom_positions = np.array(protein_atom_positions)        tree = cKDTree(protein_atom_positions)        overlapping_indices = tree.query_ball_point(indices_for_exclusion, radius)        exclude_indices = indices_for_exclusion[[len(i) > 0 for i in overlapping_indices ]]        return exclude_indices            def ray_trace_to_atom_proximity(centroid, atom_coordinates, max_distance, proximity=2.0):        centroid = np.array(centroid)        atom_coordinates = np.array(atom_coordinates)                # Dictionary to hold the minimal distance to the proximity limit along each axis, both directions        min_distances = {            'x_positive': max_distance,            'x_negative': max_distance,            'y_positive': max_distance,            'y_negative': max_distance,            'z_positive': max_distance,            'z_negative': max_distance        }                # Check each atom and each axis        for atom in atom_coordinates:            for axis in range(3):  # 0:x, 1:y, 2:z                axis_vector = np.zeros(3)                axis_vector[axis] = 1                                # Positive direction along the axis                distance_to_atom = atom - centroid                parallel_distance = np.dot(distance_to_atom, axis_vector)                perpendicular_distance = np.linalg.norm(distance_to_atom - parallel_distance * axis_vector)                                # Check if the atom is within the proximity zone                if perpendicular_distance <= proximity:                    # Update the distances if within max_distance and closer than the current record                    if 0 <= parallel_distance <= min_distances[f'{SystemTools.axis_vector_to_axis_name(axis)}_positive']:                        min_distances[f'{SystemTools.axis_vector_to_axis_name(axis)}_positive'] = parallel_distance - proximity                                        # Negative direction (check the other side of the ray)                    if -min_distances[f'{SystemTools.axis_vector_to_axis_name(axis)}_negative'] <= parallel_distance <= 0:                        min_distances[f'{SystemTools.axis_vector_to_axis_name(axis)}_negative'] = -parallel_distance - proximity                        return list(min_distances.values())    def axis_vector_to_axis_name(axis):        if axis == 0:            return 'x'        elif axis == 1:            return 'y'        elif axis == 2:            return 'z'    def get_max_min_translation(translations):        max_x = -float('inf')        min_x = float('inf')        max_y = -float('inf')        min_y = float('inf')        max_z = -float('inf')        min_z = float('inf')                for translation_dictionary in translations:            # Update max/min for x            if translation_dictionary['x_positive'] > max_x:                max_x = translation_dictionary['x_positive']            if translation_dictionary['x_negative'] < min_x:                min_x = translation_dictionary['x_negative']                        # Update max/min for y            if translation_dictionary['y_positive'] > max_y:                max_y = translation_dictionary['y_positive']            if translation_dictionary['y_negative'] < min_y:                min_y = translation_dictionary['y_negative']                        # Update max/min for z            if translation_dictionary['z_positive'] > max_z:                max_z = translation_dictionary['z_positive']            if translation_dictionary['z_negative'] < min_z:                min_z = translation_dictionary['z_negative']            return [min_x, max_x, min_y, max_y, min_z, max_z]        def SASA_shrake_rupley(protein, binding_site_residues, sasa_cutoff=5.0, level='R'):        # Create a temporary file        temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.pdb', mode='w+')        temp_file_name = temp_file.name        temp_file.close()            # Write PDB file using the proper filename        protein.openff_structure.write_pdb(temp_file_name)            # Read the structure back in using BioPython        parser = PDBParser()        structure = parser.get_structure('Molecule', temp_file_name)            # Calculate SASA using Shrake-Rupley algorithm        sr = ShrakeRupley()        sr.compute(structure, level=level)                prot = structure[0]        residues_above_sasa = []                count = []        for chain in prot:                       for num,residue in enumerate(chain):                                               key = f"{num + 1}:{chain.id}"                                 sasa = residue.sasa                if key in binding_site_residues and sasa >= sasa_cutoff:                    count.append(f':{residue.id[1]}.{chain.id}')                    residues_above_sasa.append(key)                            os.unlink(temp_file_name)                        return residues_above_sasa                        def dock_prep(docking_id,                  ligand,                   protein,                   radius,                  centroids,                  dens_map,                  system_data,                  platform = 'OpenCL',                  mi_weight = None,                  global_k = None,                  cutoff = 20.0,                  flexible_side_chains = False,                  solvent=False,                  n_cpu = None,                  sasa_cutoff = 5.0):                        #TODO! -get maximum movements in x,y and z directions!         #      -get the surface residues in the box!         #      -could possible get rid of outside reisude with ray traycing.                initial_mols = [Chem.Mol(i) for i in ligand]        n_ligands = len(initial_mols)        torsion_lists = [i.torsion_lists for i in ligand]        n_torsion = [len(i) for i in torsion_lists]                #all_new stuff!!!                binding_site_limits = SystemTools.get_segment_limits(centroids, radius)        position_residues, segment_atoms = ProteinTools.get_protein_segment(binding_site_limits, protein)        position_residues = SystemTools.SASA_shrake_rupley(protein, position_residues, sasa_cutoff)                atom_coords = []        for residue_key in position_residues:            residue = protein.get_residue(residue_key)            for atom in residue:                if atom.element != 'H':                    atom_coords.append(atom.coords)        atom_coords = np.array(atom_coords)                min_max_translations = [SystemTools.ray_trace_to_atom_proximity(i, atom_coords, 20.0, proximity=2.0) for i in centroids]                #min_max_translations = SystemTools.get_max_min_translation(min_max_translations)        #end new stuff---                all_arrays = []        n_atoms = []        #translation_bounds = np.arange(-radius / 2, radius / 2 , 0.1)        #translation_bounds_x = np.arange(-radius[0] / 2, radius[0] / 2 , 0.1)        #translation_bounds_y = np.arange(-radius[1] / 2, radius[1] / 2 , 0.1)        #translation_bounds_z = np.arange(-radius[2] / 2, radius[2] / 2 , 0.1)        #TODO! excluison criteria for binding site!!               for num in range(n_ligands):            #TODO! new stuff            translation_bounds = min_max_translations[num]            translation_bounds_x =  np.arange( -translation_bounds[1] / 2, translation_bounds[0] / 2 , 0.1)            translation_bounds_y =  np.arange( -translation_bounds[3] / 2, translation_bounds[2] / 2 , 0.1)            translation_bounds_z =  np.arange( -translation_bounds[5] / 2, translation_bounds[4] / 2 , 0.1)            #new stuff            n_atoms.append(ligand[num].GetNumAtoms())                        all_arrays.append([round(centroids[num][0] + i,3) for i in translation_bounds_x])            all_arrays.append([round(centroids[num][1] + i,3) for i in translation_bounds_y])            all_arrays.append([round(centroids[num][2] + i,3) for i in translation_bounds_z])            all_arrays.append([i for i in range(0,360,1)])            all_arrays.append([i for i in range(0,360,1)])            all_arrays.append([i for i in range(0,360,1)])                                    for i in range(n_torsion[num]):                all_arrays.append([i for i in range(0,360,1)])        if n_cpu is None:            n_cpu = round(multiprocessing.cpu_count() / 2)            if n_cpu > 20:                n_cpu = 20                                if dens_map is not None:            map_bounds = [dens_map.x_origin, dens_map.x_origin + (dens_map.x_size * dens_map.apix[0]),                           dens_map.y_origin, dens_map.y_origin + (dens_map.y_size * dens_map.apix[1]),                           dens_map.z_origin, dens_map.z_origin + (dens_map.z_size * dens_map.apix[2])]        else:            map_bounds = None                                complex_system =  OpenFFTools.openmm_complex_system(protein,                                                            ligand,                                                            centroids,                                                            dens_map = dens_map,                                                            map_bounds = map_bounds,                                                            global_k = global_k,                                                            cutoff = cutoff,                                                            flexible_side_chains = flexible_side_chains,                                                            solvent=solvent,                                                            platform = platform)                                     #binding_site_limits = SystemTools.get_segment_limits(centroids, [radius] *3)        #binding_site_limits = SystemTools.get_segment_limits(centroids, radius)        #position_residues, segment_atoms = ProteinTools.get_protein_segment(binding_site_limits, protein)                print(f"Docking with {len(position_residues)} residues.")        if len(position_residues) <= 5:            print('ChemEM - Warning: Docking with {len(position_residues)} residues, may result in inacurate solutions.')            print('Consider increasing the "docking_radius" in the conf file.')               #TODO! -        #if the point is within an atom radii remove it or if it is outside the box remove it!        '''        exclude_indices = []        for x in all_arrays[0]:            for y in all_arrays[1]:                for z in all_arrays[2]:                    exclude_indices.append([x,y,z])                    #exclude_translation_indices = SystemTools.set_excluded_indices( np.array([[x,y,z]]),                    #                                                    protein, position_residues,                    #                                                    binding_site_limits)                    #if exclude_translation_indices:                    #    exclude_indices.append([x,y,z])        exclude_translation_indices = SystemTools.set_excluded_indices( exclude_indices,                                                            protein, position_residues,                                                            binding_site_limits)        '''        positions = []        position_keys = {}        protein_aromatic = []        distance_matrix_atom_elements = []        distance_matrix_hbond_donor_acceptor_hpi = []        distance_matrix_hydrogens = {}                for residue_key in position_residues:            residue = protein.get_residue(residue_key)            if len(residue.aromatic_rings) > 0:                protein_aromatic.append(residue_key)                        for atom in residue:                donor_acceptor_hpi = [False,False, False]                                if atom.donor_potential > 0:                    donor_acceptor_hpi[0] = True                if atom.acceptor_potential > 0:                    donor_acceptor_hpi[1] = True                                distance_matrix_hbond_donor_acceptor_hpi.append(donor_acceptor_hpi)                distance_matrix_hydrogens[len(positions)] = list(atom.hydrogens.values())                chemem_key = f'{residue_key}.{atom.atom_name}'                distance_matrix_atom_elements.append(atom.element)                position_keys[chemem_key] = len(positions)                atom_idx = protein.__chemem_conversion_keys__[chemem_key]                pos = complex_system.positions[atom_idx]                positions.append([ round(pos.x * 10, 3), round(pos.y * 10, 3),round(pos.z * 10, 3)])                                num_prot_binding_site_atoms = len(positions)                        for lig in ligand:            rd_atoms = lig.GetAtoms()            lig_key = lig.residue_name            for atom, rd_atom in zip(lig, rd_atoms):                                distance_matrix_hydrogens[len(positions)] = atom.hydrogens                                donor_acceptor_hpi = [False,False, False]                                if atom.donor_potential > 0:                    donor_acceptor_hpi[0] = True                                    if atom.acceptor_potential > 0:                    donor_acceptor_hpi[1] = True                                                if rd_atom.GetSymbol() in system_data.hydrophobic_atoms:                    mol_rd_hpi = [i.GetSymbol() for i in rd_atom.GetNeighbors()]                    mol_sum_hpi = sum([1 for i in mol_rd_hpi if i in system_data.hydrophobic_atoms])                                        if len(mol_rd_hpi) == mol_sum_hpi:                        donor_acceptor_hpi[2] = True                                        distance_matrix_hbond_donor_acceptor_hpi.append(donor_acceptor_hpi)                                distance_matrix_atom_elements.append(atom.element)                full_key = f'{lig_key}.{atom.atom_name}'                position_keys[full_key] = len(positions)                positions.append(atom.coords)                positions = np.array(positions)                        distance_matrix = DistanceMatrix(all_positions = positions,                                         position_keys = position_keys,                                         protein_end_idx = num_prot_binding_site_atoms,                                         atom_elements = distance_matrix_atom_elements,                                         donor_acceptor_hpi = distance_matrix_hbond_donor_acceptor_hpi,                                         hydrogens = distance_matrix_hydrogens)               #TODO! add the excluded list to here.         #When implementing new docking score change this mechanism!        docking_run = ACO(docking_id = docking_id,                          protein = protein,                          initial_mols = initial_mols,                          n_ligands = n_ligands,                          n_atoms = n_atoms,                          torsion_lists = torsion_lists,                          n_torsions = n_torsion,                          binding_site_radius = radius,                          system_data = system_data,                          complex_system= complex_system,                          distance_matrix = distance_matrix,                          protein_aromatic = protein_aromatic,                          n_cpus= n_cpu,                          all_arrays = all_arrays,                          mi_weight = mi_weight,                          _ligand = ligand,                          _centroids = centroids,                          _dens_map = dens_map)                          #exclude_translation_indices = exclude_translation_indices)                return docking_run                                                