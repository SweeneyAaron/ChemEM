import numpy as npimport multiprocessingfrom ChemEM.tools.protein_tools import ProteinToolsfrom ChemEM.tools.openff_tools import OpenFFToolsfrom ChemEM.tools.map_tools import MapToolsfrom ChemEM.data_classes.system import Segment, ACOfrom ChemEM.data_classes.base_classes import DistanceMatrixfrom rdkit import Chemimport pdb as pythondbclass SystemTools():            def _update_system_data_ids(system):                system_data_id = id(system.system_data)        for protein in system.proteins.values():            protein.__base_data__ = system_data_id        def _update_protein_ids(system):        for protein in system.proteins.values():            protein_id = id(protein)            for residue in protein.residues:                residue.__prot_ref__ = protein_id        def segment_system(system, centroid, box_dimensions, exclude = None):                segment_limits = SystemTools.get_segment_limits(centroid, box_dimensions)        segment_proteins = {}        segment_protein_mols = {}        segment_maps = {}        segment_ligands = {}                for protein in system.proteins.values():            #pick one!!!            segment_residues, segment_atoms = ProteinTools.get_protein_segment(segment_limits, protein)                        if len(segment_residues) == 0:                continue                        segment_mol = ProteinTools.rd_mol_from_residue_keys(protein,  segment_residues)                                    segment_proteins[protein.protein_id] = segment_residues            segment_protein_mols[protein.protein_id] = segment_mol                    #add segment mols togheter!!!TODO!        #add ligands!!!TODO!        #add maps togheter!! normalise first!!                #can only use one map at the moment!!        for densmap in system.maps.values():                        segment_map = MapTools.get_map_segement(densmap, segment_limits)            segment_maps[densmap.map_id] = segment_map            segment_map.map_id = densmap.map_id            segment_map.resolution = densmap.resolution            segment_map.map_contour = densmap.map_contour                segment_id = f'S{len(system.segments)}'                        return segment_id, Segment(segment_id = segment_id,                       centroid = centroid,                       box_dimensions = box_dimensions,                       proteins = segment_proteins,                       _protein_mols = segment_protein_mols,                       ligands = segment_ligands,                       maps = segment_maps)                            def get_segment_limits(centroids, limits):                max_x, max_y, max_z = -9999999, -999999, -9999999        min_x, min_y, min_z = 999999, 999999, 999999        for centroid in centroids:            x,y,z = centroid            if x > max_x:                max_x = x            if x < min_x:                min_x = x                        if y > max_y:                max_y = y            if y < min_y:                min_y = y                        if z > max_z:                max_z = z            if z < min_z:                min_z = z                min_x -= (limits[0]/2)        min_y -= (limits[0]/2)        min_z -= (limits[0]/2)                max_x += (limits[0]/2)        max_y += (limits[0]/2)        max_z += (limits[0]/2)                box_lim = [min_x, max_x, min_y, max_y, min_z, max_z]                return box_lim        def dock_prep(docking_id,                  ligand,                   protein,                   radius,                  centroids,                  dens_map,                  system_data,                  platform = 'OpenCL',                  mi_weight = None,                  global_k = None,                  cutoff = 20.0,                  flexible_side_chains = False,                  solvent=False,                  n_cpu = None):                        initial_mols = [Chem.Mol(i) for i in ligand]        n_ligands = len(initial_mols)        torsion_lists = [i.torsion_lists for i in ligand]        n_torsion = [len(i) for i in torsion_lists]                                all_arrays = []        n_atoms = []        translation_bounds = np.arange(-radius / 2, radius / 2 , 0.1)                       for num in range(n_ligands):            n_atoms.append(ligand[num].GetNumAtoms())                        all_arrays.append([round(centroids[num][0] + i,3) for i in translation_bounds])            all_arrays.append([round(centroids[num][1] + i,3) for i in translation_bounds])            all_arrays.append([round(centroids[num][2] + i,3) for i in translation_bounds])            all_arrays.append([i for i in range(0,360,1)])            all_arrays.append([i for i in range(0,360,1)])            all_arrays.append([i for i in range(0,360,1)])                        for i in range(n_torsion[num]):                all_arrays.append([i for i in range(0,360,1)])                        if n_cpu is None:            n_cpu = round(multiprocessing.cpu_count() / 2)            if n_cpu > 20:                n_cpu = 20                        if dens_map is not None:            map_bounds = [dens_map.x_origin(), dens_map.x_origin() + (dens_map.x_size() * dens_map.apix[0]),                           dens_map.y_origin(), dens_map.y_origin() + (dens_map.y_size() * dens_map.apix[1]),                           dens_map.z_origin(), dens_map.z_origin() + (dens_map.z_size() * dens_map.apix[2])]        else:            map_bounds = None                                complex_system =  OpenFFTools.openmm_complex_system(protein,                                                            ligand,                                                            centroids,                                                            dens_map = dens_map,                                                            map_bounds = map_bounds,                                                            global_k = global_k,                                                            cutoff = cutoff,                                                            flexible_side_chains = flexible_side_chains,                                                            solvent=solvent,                                                            platform = platform)                                     binding_site_limits = SystemTools.get_segment_limits(centroids, [radius] * 3)        position_residues, segment_atoms = ProteinTools.get_protein_segment(binding_site_limits, protein)                '''        position_residues = []        for centroid in centroids:                        binding_site_limits = SystemTools.get_segment_limits([centroid], [radius] * 3)            segment_residues, segment_atoms = ProteinTools.get_protein_segment(binding_site_limits, protein)            position_residues += [i for i in segment_residues if i not in position_residues]        '''                positions = []        position_keys = {}        protein_aromatic = []        distance_matrix_atom_elements = []        distance_matrix_hbond_donor_acceptor_hpi = []        distance_matrix_hydrogens = {}                for residue_key in position_residues:            residue = protein.get_residue(residue_key)            if len(residue.aromatic_rings) > 0:                protein_aromatic.append(residue_key)                        for atom in residue:                donor_acceptor_hpi = [False,False, False]                                if atom.donor_potential > 0:                    donor_acceptor_hpi[0] = True                if atom.acceptor_potential > 0:                    donor_acceptor_hpi[1] = True                                distance_matrix_hbond_donor_acceptor_hpi.append(donor_acceptor_hpi)                distance_matrix_hydrogens[len(positions)] = list(atom.hydrogens.values())                chemem_key = f'{residue_key}.{atom.atom_name}'                distance_matrix_atom_elements.append(atom.element)                position_keys[chemem_key] = len(positions)                atom_idx = protein.__chemem_conversion_keys__[chemem_key]                pos = complex_system.positions[atom_idx]                positions.append([ round(pos.x * 10, 3), round(pos.y * 10, 3),round(pos.z * 10, 3)])                                num_prot_binding_site_atoms = len(positions)                        for lig in ligand:            rd_atoms = lig.GetAtoms()            lig_key = lig.residue_name            for atom, rd_atom in zip(lig, rd_atoms):                                distance_matrix_hydrogens[len(positions)] = atom.hydrogens                                donor_acceptor_hpi = [False,False, False]                                if atom.donor_potential > 0:                    donor_acceptor_hpi[0] = True                                    if atom.acceptor_potential > 0:                    donor_acceptor_hpi[1] = True                                                if rd_atom.GetSymbol() in system_data.hydrophobic_atoms:                    mol_rd_hpi = [i.GetSymbol() for i in rd_atom.GetNeighbors()]                    mol_sum_hpi = sum([1 for i in mol_rd_hpi if i in system_data.hydrophobic_atoms])                                        if len(mol_rd_hpi) == mol_sum_hpi:                        donor_acceptor_hpi[2] = True                                        distance_matrix_hbond_donor_acceptor_hpi.append(donor_acceptor_hpi)                                distance_matrix_atom_elements.append(atom.element)                full_key = f'{lig_key}.{atom.atom_name}'                position_keys[full_key] = len(positions)                positions.append(atom.coords)                positions = np.array(positions)                                distance_matrix = DistanceMatrix(all_positions = positions,                                         position_keys = position_keys,                                         protein_end_idx = num_prot_binding_site_atoms,                                         atom_elements = distance_matrix_atom_elements,                                         donor_acceptor_hpi = distance_matrix_hbond_donor_acceptor_hpi,                                         hydrogens = distance_matrix_hydrogens)                      docking_run = ACO(docking_id = docking_id,                          protein = protein,                          initial_mols = initial_mols,                          n_ligands = n_ligands,                          n_atoms = n_atoms,                          torsion_lists = torsion_lists,                          n_torsions = n_torsion,                          binding_site_radius = radius,                          system_data = system_data,                          complex_system= complex_system,                          distance_matrix = distance_matrix,                          protein_aromatic = protein_aromatic,                          n_cpus= n_cpu,                          all_arrays = all_arrays,                          mi_weight = mi_weight,                          _ligand = ligand,                          _centroids = centroids,                          _dens_map = dens_map)                return docking_run                                                