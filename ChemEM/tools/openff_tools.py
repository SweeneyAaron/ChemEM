# This file is part of the ChemEM software.## Copyright (c) 2023 - Topf Group & Leibniz Institute for Virology (LIV),# Hamburg, Germany.## This module was developed by:#   Aaron Sweeney    <aaron.sweeney AT cssb-hamburg.de>#   Tom Mulvaney <thomas.mulvaney AT cssb-hamburg.de>import osimport sysimport jsonimport timeimport randomimport numpy as npimport tempfileimport copyimport iofrom collections.abc import Iterablefrom dataclasses import dataclass, fieldfrom scipy.ndimage import gaussian_filterfrom scipy.spatial.distance import euclideanfrom ChemEM.tools.rdtools import RDToolsfrom ChemEM.scoring_functions import ScoringFunctionsfrom ChemEM.tools.math import MathToolsfrom rdkit import Chemfrom rdkit.Geometry import Point3Dfrom rdkit.Chem.rdmolops import AddHs, AssignStereochemistryFrom3Dfrom rdkit.Chem import AssignStereochemistryfrom openff.toolkit.topology import Moleculefrom openff.toolkit.typing.engines.smirnoff import ForceFieldfrom openff.interchange import Interchangeimport parmedfrom openmm import MonteCarloBarostat, XmlSerializer, app, unit, CustomCompoundBondForce, Continuous3DFunction, vec3, Vec3from openmm.app import HBonds, NoCutoff, PDBFile, Modeller, Topologyfrom openmm.unit.quantity import Quantityfrom openmm.unit import normfrom openmm import LangevinIntegrator, Platformfrom pdbfixer import PDBFixerclass OpenFFSimulation():    def __init__(self, simulation,                  positions,                  protein_atoms,                  integrator,                 flexible_side_chains,                 solvent):        self.simulation = simulation        self.positions = positions        self.num_protein_atoms = protein_atoms        self.integrator = integrator        self.flexible_side_chains = flexible_side_chains        self.solvent = solvent        @dataclassclass PostRefinedSolution:    ligand_id : str    cycle : int    chemem_score : float     refined_solution :  object = field(repr = False)    off_positions : object  = field(repr = False)    chemem_protein : object  = field(repr = False)    _dist_matrix : object  = field(repr = False)    class OpenFFTools():        def get_excluded_ligand_atoms(docking_job, hold_fragment):                        start_idx = docking_job.complex_system.num_protein_atoms        hold_fragment_idx_dic = {}        for ligand in docking_job._ligand:            key= ligand.residue_name            atom_dic = {}            for idx in range(ligand.num_atoms):                atom_dic[idx] = start_idx                start_idx += 1                        hold_fragment_idx_dic[key] = atom_dic             lig_hs = Chem.AddHs(ligand.copy())            start_idx += lig_hs.GetNumAtoms() - ligand.num_atoms                excluded_atoms = OpenFFTools.get_excluded_atoms(hold_fragment, hold_fragment_idx_dic)        excluded_atoms = list(set(excluded_atoms))                return excluded_atoms    def get_excluded_atoms(hold_fragment, hold_fragment_idx_dic):        exclude = []                for frag in hold_fragment:            lig_key, atoms = frag.split(':')            atoms = [int(i) for i in atoms.split('.')]            atoms = [hold_fragment_idx_dic[lig_key][i] for i in atoms]            exclude += atoms                return exclude            def load_ligand_structure(molecule):                ligand_off_molecule = Molecule.from_rdkit(molecule)        ligand_off_molecule.assign_partial_charges('mmff94')        force_field = ForceField("openff_unconstrained-2.0.0.offxml")        interchange = Interchange.from_smirnoff(topology=[ligand_off_molecule], force_field=force_field, charge_from_molecules=[ligand_off_molecule])        ligand_system = interchange.to_openmm()                        mol_w_hs = AddHs(molecule, addCoords=True)        virtual_file = io.StringIO(Chem.MolToPDBBlock(mol_w_hs))        ligand_pdbfile = PDBFile(virtual_file)        ligand_structure = parmed.openmm.load_topology(            ligand_pdbfile.topology, ligand_system, xyz=ligand_pdbfile.positions        )                return ligand_structure        def get_forcefield(forcefield):        #amber of charmm         inc_forcefields = []        if 'amber14' in forcefield:            inc_forcefields.append('amber14-all.xml')        elif 'charmm36' in forcefield:            inc_forcefields.append('charmm36.xml')            inc_forcefields.append("implicit/gbn2.xml")        else:            inc_forcefields += ['amber14-all.xml', "implicit/gbn2.xml", "amber14/tip3pfb.xml"]                        for force in forcefield:            if force not in ['amber14', 'charmm36'] and force not in inc_forcefields:                inc_forcefields.append(force)                omm_forcefield = app.ForceField(*inc_forcefields)                        return omm_forcefield                def load_protein_structure(protein_file, forcefield):        """         Loads a protein structure into ChemEM by building an OpenMM system and extracting the necessary data.                 This function attempts to load a protein file into an OpenMM system using several methods.         If the initial attempt fails, it tries alternative methods involving model truncation and residue insertion.         It returns multiple objects essential for further computations in ChemEM.                 Parameters         ----------         protein_file : str             The path to the protein file to load into an OpenMM system.                 Returns         -------         chem_em_residue_data : dict             A dictionary containing residue data formatted for ChemEM.         receptor_structure : parmed.structure.Structure             The ParmEd structure object of the receptor.         openff_chemem_conversion_keys : dict             A dictionary mapping OpenFF conversion keys used in ChemEM.         dict             A dictionary with reversed key-value pairs from `openff_chemem_conversion_keys`.         missing_res : list or None             A list of missing residues if residue insertion was necessary, otherwise None.                 Raises         ------         SystemExit             If all attempts to build the OpenMM system fail, the function exits the program and prints all accumulated errors.                 """                warnings = []        omm_forcefield = OpenFFTools.get_forcefield(forcefield)                try:            receptor_pdbfile = PDBFile(protein_file)                    # Load the AMBER protein force field through OpenMM.            #omm_forcefield = app.ForceField("amber14-all.xml", "implicit/gbn2.xml",  "amber14/tip3pfb.xml")            receptor_system = omm_forcefield.createSystem(receptor_pdbfile.topology)            missing_res = None            receptor_structure = parmed.openmm.load_topology(                receptor_pdbfile.topology, receptor_system, xyz=receptor_pdbfile.positions            )                        chem_em_residue_data , openff_chemem_conversion_keys = OpenFFTools.openFF_structure_to_ChemEM_residues(receptor_structure.residues)            return chem_em_residue_data , receptor_structure, openff_chemem_conversion_keys  , {v : k for k, v in openff_chemem_conversion_keys.items()}, missing_res                    except Exception as e:             warnings.append(f'ChemEM-Error: receptor failed building direct from file {protein_file}.\n Full Error {e}\n')                            #try build the model with truncation        try:            #omm_forcefield = app.ForceField("amber14-all.xml", "implicit/gbn2.xml", "amber14/tip3pfb.xml")            fixer = PDBFixer(protein_file)            receptor_openmm = PDBFile(protein_file)            receptor_pdbfile, receptor_system = OpenFFTools.build_openmm_model_from_pdbfixer(fixer,                                                                                              omm_forcefield,                                                                                              receptor_openmm)                                                missing_res = None            receptor_structure = parmed.openmm.load_topology(receptor_pdbfile.topology, receptor_system, xyz=receptor_pdbfile.positions )            chem_em_residue_data , openff_chemem_conversion_keys = OpenFFTools.openFF_structure_to_ChemEM_residues(receptor_structure.residues)            return chem_em_residue_data , receptor_structure, openff_chemem_conversion_keys  , {v : k for k, v in openff_chemem_conversion_keys.items()}, missing_res                                except Exception as e:             warnings.append(f'ChemEM-Error: receptor failed building with chain truncation {protein_file}.\n Full Error {e}\n')                        #try build the model with insertion         try:            receptor_pdbfile, missing_res = OpenFFTools.pdb_fixer(protein_file)                        #omm_forcefield = app.ForceField("amber14-all.xml", "implicit/gbn2.xml", "amber14/tip3pfb.xml")            receptor_system = omm_forcefield.createSystem(receptor_pdbfile.topology)            receptor_structure = parmed.openmm.load_topology(                receptor_pdbfile.topology, receptor_system, xyz=receptor_pdbfile.positions            )            chem_em_residue_data , openff_chemem_conversion_keys = OpenFFTools.openFF_structure_to_ChemEM_residues(receptor_structure.residues)            return chem_em_residue_data , receptor_structure, openff_chemem_conversion_keys  , {v : k for k, v in openff_chemem_conversion_keys.items()}, missing_res                                except Exception as e:            warnings.append(f'ChemEM-Error: receptor failed building with residue insertion {protein_file}.\n Full Error {e}\n')        for error in warnings:            print(error)        sys.exit()                        def model_to_fixer_interchange(modeller):        with tempfile.NamedTemporaryFile(mode='w+', delete=True) as temp:            PDBFile.writeFile(modeller.topology, modeller.positions, temp)            temp.flush()            receptor_pdbfile = PDBFixer(temp.name)                    return receptor_pdbfile        def fixer_to_model_interchange(fixer):        with tempfile.NamedTemporaryFile(mode='w+', delete=True) as temp:            PDBFile.writeFile(fixer.topology, fixer.positions, temp)            temp.flush()            receptor_pdbfile = PDBFile(temp.name)            return receptor_pdbfile                def build_openmm_model_from_pdbfixer(fixer, forcefield, openmm_receptor):                new_topology, new_positions = OpenFFTools.split_chains_on_breaks(fixer)        modeller = Modeller(new_topology, fixer.positions)        new_fixer = OpenFFTools.model_to_fixer_interchange(modeller)        #add more!!!        new_fixer.findNonstandardResidues()        new_fixer.replaceNonstandardResidues()        new_fixer.findMissingResidues()        new_fixer.findMissingAtoms()        new_fixer.addMissingAtoms()        new_fixer.addMissingHydrogens(7.4)        new_modeller = OpenFFTools.fixer_to_model_interchange(new_fixer)                system = forcefield.createSystem(new_modeller.topology)            return new_modeller, system        def split_chains_on_breaks(fixer):                def residues_sequential(res1, res2):            return int(res2.id) == int(res1.id) + 1            # New topology and positions        new_topology = Topology()        new_positions = []            # Original topology and positions        original_topology = fixer.topology        original_positions = fixer.positions            # Iterate over chains in the original topology        for chain in original_topology.chains():            new_chain = new_topology.addChain()            prev_residue = None            for res in chain.residues():                               if prev_residue and not residues_sequential(prev_residue, res):                    # If there is a chain break, start a new chain                    new_chain = new_topology.addChain()                # Add residue to the current chain                new_residue = new_topology.addResidue(res.name, new_chain, id=res.id)                for atom in res.atoms():                    new_atom = new_topology.addAtom(atom.name, atom.element, new_residue)                    new_positions.append(original_positions[atom.index])                                prev_residue = res                        return new_topology, new_positions                def pdb_fixer(protein_file):        fixer = PDBFixer(protein_file)        ori_positions = fixer.positions                      residues_before = list(fixer.topology.residues())        res_before = [(i.chain.id, i.id) for i in residues_before]        fixer.findMissingResidues()        fixer.findMissingAtoms()        fixer.addMissingAtoms()        fixer.addMissingHydrogens(7.0)        residues_after = list(fixer.topology.residues())        res_after = [(i.chain.id, i.id) for i in residues_after]                missing_res = OpenFFTools.get_missing_residue_keys(fixer)        with tempfile.NamedTemporaryFile(mode='w+', delete=True) as temp:            PDBFile.writeFile(fixer.topology, fixer.positions,temp)            temp.flush()            receptor_pdbfile = PDBFile(temp.name)         return receptor_pdbfile, missing_res        def het_handeler(het_residues, positions):                                for residue in het_residues[1:]:            new_topology =  Topology()            new_chain = new_topology.addChain()            new_positions = []            new_residue = new_topology.addResidue(residue.name, new_chain, residue.id)            for atom in residue.atoms():                new_atom = new_topology.addAtom(atom.name, atom.element, new_residue)                new_positions.append(positions[atom.index])                                    if new_residue is not None:                                               new_positions = [i._value * 10 for i in new_positions]                #new_positions = np.array(new_positions) * 10                #new_positions_corrected = [vec3.Vec3(x, y, z) for x, y, z in np.array(new_positions)/unit.nanometer]  # Convert to list of Vec3 without units                #find tmp dir!!!                                #new_res_file = os.path.join(OpenFFTools.get_tmp_path(), f"{residue.name}_{residue.chain.id}_{residue.id}.pdb")                new_res_file = os.path.join('/Users/aaron.sweeney/Documents/ChemEM_conda/', f"{residue.name}_{residue.chain.id}_{residue.id}.pdb")                with open(new_res_file, "w") as file:                    PDBFile.writeFile(new_topology, new_positions, file)                                #remove this file once done                rd_mol = RDTools.get_rd_mol(new_res_file,'pdb', sanitize = True)                                            #AssignStereochemistry(rd_mol, force=True, cleanIt=True)                AssignStereochemistryFrom3D(rd_mol, confId=0)                openff_structure = OpenFFTools.load_ligand_structure(rd_mol)                                        def get_tmp_path():        if getattr(sys, 'frozen', False):            # If bundled executable, use the temporary directory path set by PyInstaller            base_path = sys._MEIPASS            path = os.path.join(base_path, '__tmp__')                                else:            # If running as a script, use the script's directory            #base_path = os.path.dirname(os.path.abspath(__file__))            path = f'{os.path.dirname(os.path.abspath(__file__))}/__tmp__/'        return path        def get_missing_residue_keys(fixer):        missing_residues = fixer.missingResidues        missing_res_keys = list(missing_residues)        missing_res_keys.sort(key=lambda x: (x[0], x[1]))        index_shift = [0] * len(list(fixer.topology.chains()))        new_keys = []        for key in missing_res_keys:            chainIndex, residueIndex = key            num_missing_residues = len(missing_residues[key])            adjusted_residueIndex = residueIndex + index_shift[chainIndex]            for i in range(num_missing_residues):                new_keys.append((chainIndex, adjusted_residueIndex + i))                                    index_shift[chainIndex] += num_missing_residues                    return new_keys                def openFF_structure_to_ChemEM_residues(residues):                        path = os.path.dirname(os.path.abspath(__file__))        openff_chemem_conversion_keys = {}        mols = []        for res in residues:            mol = RDTools.mol_from_sdf(f'{path}/amino_acids/{res.name}.sdf')            mol, openff_scoring_conversion_idx = OpenFFTools.openFF_to_ChemEM_residue( mol, res, path)            mols.append(mol)            openff_chemem_conversion_keys.update(openff_scoring_conversion_idx)               return mols, openff_chemem_conversion_keys             def openFF_to_ChemEM_residue(mol, residue, path):                json_path = f'{path}/amino_acids/{residue.name}.json'        with open(json_path, 'r') as f:            ligand_data = json.load(f)                json_hydrogen_path = f'{path}/amino_acids/{residue.name}_hydrogens.json'        with open(json_hydrogen_path, 'r') as f:            ligand_hydrogen_data = json.load(f)                           conf = mol.GetConformer()                hydrogens = {i: {} for i in ligand_data}                residue_number = residue.number        residue_name = residue.name        residue_chain = residue.chain        residue_key = f'{residue_number}:{residue_chain}'        residue_conversion_keys = {}                        for atom in residue.atoms:            #assign hydrogens to atoms            #add this atom to the mol later on            if atom.name == 'OXT':                continue                        opennmm_scoring_conversion_idx = atom._idx            atom_key = f'{residue_key}.{atom.name}'            #This may change!!#now included hydrogens!!            residue_conversion_keys[opennmm_scoring_conversion_idx] = atom_key                                    if atom.name.startswith('H'):                pos = [atom.xx, atom.xy, atom.xz]                hydrogens[ligand_hydrogen_data[atom.name]][atom.name] = pos                                continue                        x, y, z = [atom.xx, atom.xy, atom.xz]                                    new_coord_index = ligand_data[atom.name]                            conf.SetAtomPosition(new_coord_index, Point3D(x, y, z))                residue_data = {'name' : residue_name, 'number' : residue_number, 'chain' : residue_chain, 'key': residue_key,                         'mol' : mol, 'hydrogens' : hydrogens, 'atom_indexs' : ligand_data}                return residue_data, residue_conversion_keys                def write_complex_system(positions, topology, out_file, missing_res = None):                new_topology = Topology()        new_positions = []        atoms_to_remove = []        old_to_new_atoms = {}                if missing_res is None:            new_positions = positions            new_topology = topology        else:            for chain in list(topology.chains()):                new_chain = new_topology.addChain(chain.id)                for num,residue in enumerate(list(chain.residues())):                    key = (chain.index, num)                                        #key = (chain.id, residue.id)                    if key not in missing_res:                        new_residue = new_topology.addResidue(residue.name, new_chain, residue.id, residue.insertionCode)                        for atom in residue.atoms():                            new_atom = new_topology.addAtom(atom.name, atom.element, new_residue)                                                elif key in missing_res:                                                for atom in residue.atoms():                            atoms_to_remove.append(atom.index)                        new_positions = copy.deepcopy(positions)                        for index in sorted(atoms_to_remove, reverse=True):                del new_positions[index]                        with open(out_file, 'w') as f:            PDBFile.writeFile(new_topology, new_positions, f)                                                            def write_complex_system_old(positions,topology,out_file, missing_res = None):                topology = copy.deepcopy(topology)        atoms_to_remove = []        for chain in list(topology.chains()):                                    for num,residue in enumerate(list(chain.residues())):                key = (chain.index, num)                if key in missing_res:                    for atom in residue.atoms():                        atoms_to_remove.append(atom.index)                                    def get_missing_res(missing_res):        new_missing_res = []        for key in missing_res:            chain = key[0]            start_idx  = key[1]            for i in missing_res[key]:                if (chain, start_idx) in new_missing_res:                                        new_missing_res.append((chain, start_idx))                    start_idx += 1                                return new_missing_res                        def get_global_k(resolution):        if resolution < 3.0:            return 75.0                else:            return 25.0                    def compute_map_field(m, blur=0, d3d_func=None):        #f = CustomCompoundBondForce(1,'')        #     d3d_func = Discrete3DFunction(*m.fullMap.shape, m.fullMap.ravel().copy())        morg = np.array(m.origin)[::-1] - m.apix/2        mdim = np.array(m.box_size)*m.apix        mmax = morg+mdim        mod_m = gaussian_filter(m.density_map, blur)        minmaxes = np.array(list(zip(morg/10, mmax/10))).ravel()                if d3d_func is None:            d3d_func = Continuous3DFunction(                *mod_m.shape, mod_m.ravel(order="F"), *minmaxes)        else:            d3d_func.setFunctionParameters(                *mod_m.shape, mod_m.ravel(order="F"), *minmaxes)                return d3d_func    def map_potential_force_field(m, global_k, blur=0):                 f = CustomCompoundBondForce(1, '')        d3d_func = OpenFFTools.compute_map_field(m, blur)        f.addTabulatedFunction(name='map_potential', function=d3d_func)        f.addGlobalParameter(name='global_k', defaultValue=global_k)        f.addPerBondParameter(name='individual_k')        f.setEnergyFunction('-global_k * individual_k * map_potential(z1,y1,x1)')        return f                 def pin_force():        expr = "pin_k * ((x1 - x0)^2 + (y1 - y0)^2 + (z1 - z0)^2)"        f = CustomCompoundBondForce(1, expr)        f.addPerBondParameter("pin_k")        f.addPerBondParameter("x0")        f.addPerBondParameter("y0")        f.addPerBondParameter("z0")        return f        def pin_atoms(idx_to_pin, struct, pin_k=500):        pin_f = OpenFFTools.pin_force()        for atom_index in idx_to_pin:                        atm = struct.atoms[atom_index]            x0, y0, z0 = Quantity(                value=[atm.xx, atm.xy, atm.xz], unit=unit.angstrom)            #x0, y0, z0 = atm.xx, atm.xy, atm.xz            pin_f.addBond([atom_index], [pin_k, x0, y0, z0])        return pin_f        def get_binding_site_idx(struct, centroid, radius, system_ligands = None):        aminoacids = ["ALA", "ARG", "ASN", "ASP", "CYS", "GLU", "GLN", "GLY", "HIS",                      "ILE", "LEU", "LYS", "MET", "PHE", "PRO", "SER", "THR", "TRP", "TYR", "VAL"]        ligand_name = ['NA', 'MG']        exc_atms = []        inc_atms = []                if system_ligands is None:            system_ligands = []                for atm in struct.atoms:            atm_idx = atm.idx            if atm.residue.name in aminoacids or atm.residue.name in ligand_name:                exc_atms.append(atm_idx)            elif atm.residue.name in ligand_name:                exc_atms.append(atm_idx)                        elif atm.residue.number in system_ligands:                exc_atms.append(atm_idx)                        else:                inc_atms.append(atm_idx)                return exc_atms, inc_atms        def get_binding_site_idx_flexible(struct, centroids, radius, map_bounds,system_ligands = None):        #raidus = 15.0                if system_ligands is None:            system_ligands = []        inc_res = []        exc_res = []        aminoacids = ["ALA", "ARG", "ASN" ,"ASP", "CYS", "GLU","GLN", "GLY", "HIS", "ILE","LEU", "LYS", "MET", "PHE", "PRO", "SER","THR", "TRP", "TYR","VAL"]        backbone_atoms = ['N', 'CA','C', 'O', 'H', 'HA']        ligand_name = ['NA', 'MG'] #[] ions don't move very far now!        d = []        for atm in struct.atoms:            atm_coord = [atm.xx,  atm.xy, atm.xz]                        if atm.residue.number in system_ligands:                exc_res.append(atm.residue.number)                        elif atm.residue.name not in aminoacids and atm.residue.name not in ligand_name:                if atm.residue.number not in inc_res:                    inc_res.append(atm.residue.number)            else:                for centroid in centroids:                    dist = MathTools.euclidean_distance(atm_coord, centroid)                    #dist = euclidean(atm_coord, centroid)                                        if dist  <= radius:                        d.append((dist, atm_coord, atm))                                            if atm.residue.number not in inc_res:                                        inc_res.append(atm.residue.number)                                       exc_atms = []        inc_atms = []                        for atm in struct.atoms:            atm_idx = atm.idx                                    if atm.residue.number not in inc_res:                exc_atms.append(atm_idx)                                        elif atm.residue.name in ligand_name:                exc_atms.append(atm_idx)                        elif atm.residue.name not in aminoacids:                inc_atms.append(atm_idx)                                        elif atm.residue.name in aminoacids and atm.name in backbone_atoms:                exc_atms.append(atm_idx)                            elif atm.residue.name in ligand_name:                exc_atms.append(atm_idx)                            elif map_bounds is None:                                inc_atms.append(atm_idx)                                            elif atm.xx < map_bounds[0] or atm.xx > map_bounds[1]:                exc_atms.append(atm_idx)                            elif atm.xy < map_bounds[2] or atm.xy > map_bounds[3]:                exc_atms.append(atm_idx)                            elif atm.xz < map_bounds[4] or atm.xz > map_bounds[5]:                exc_atms.append(atm_idx)                            else:                inc_atms.append(atm_idx)                return exc_atms, inc_atms        def openmm_simulation_complex_system(protein, ligand):                complex_structure =  protein.openff_structure + ligand.openff_structure                def openmm_complex_system(protein,                               ligands,                              centroid,                              dens_map = None,                              map_bounds = None,                              global_k = None,                              cutoff = 15.0,                              flexible_side_chains = False,                              solvent=False,                              platform = 'OpenCL',                              pin_k = 5000,                              exclude = None): #send in through post processing!!!                        complex_structure =  protein.openff_structure + ligands[0].openff_structure                for mol in ligands[1:]:            complex_structure += mol.openff_structure                        if solvent == True:            complex_system = complex_structure.createSystem(                nonbondedMethod=NoCutoff,                nonbondedCutoff=9.0 * unit.angstrom,                constraints=HBonds,                removeCMMotion=False,                implicitSolvent=app.GBn2            )        else:            complex_system = complex_structure.createSystem(nonbondedMethod=NoCutoff,                                                            nonbondedCutoff=9.0 * unit.angstrom,                                                            constraints=HBonds,                                                             removeCMMotion=False,                                                             rigidWater=True)                        system_ligands = [protein.get_residue(i).residue_number for i in protein.system_ligands]        #HERER        if flexible_side_chains == True:                    exc_atoms, inc_atoms = OpenFFTools.get_binding_site_idx_flexible(                complex_structure , centroid, cutoff, map_bounds, system_ligands = system_ligands)                                else:            exc_atoms, inc_atoms = OpenFFTools.get_binding_site_idx(                complex_structure , centroid, cutoff, system_ligands = system_ligands)                if exclude is not None:            for idx in exclude:                if idx not in exc_atoms:                    exc_atoms.append(idx)                    force_group = 0        for force in complex_system.getForces():            force.setForceGroup(force_group)            force_group += 1                       if dens_map is not None:            #add map potential            copy_map = dens_map.copy()            c_level = dens_map.map_contour            copy_map.density_map =  copy_map.density_map * (copy_map.density_map >= c_level)            copy_map.density_map = copy_map.density_map / np.amax(copy_map.density_map)                        if global_k is None:                global_k = OpenFFTools.get_global_k(dens_map.resolution)                                                mp = OpenFFTools.map_potential_force_field(copy_map, global_k)            # add bonds to force field            for idx in inc_atoms:                mp.addBond([idx], [1.0])            # add force here potential for map            force_idx = complex_system.addForce(mp)            complex_system.getForce(force_idx).setForceGroup(force_group)            force_group += 1                # pin remaining atoms        p_force = OpenFFTools.pin_atoms(            exc_atoms, complex_structure, pin_k=pin_k)            pin_idx = complex_system.addForce(p_force)                complex_system.getForce(pin_idx).setForceGroup(force_group)                integrator = LangevinIntegrator(300*unit.kelvin, 1.0/unit.picoseconds,                                        1.0*unit.femtoseconds)                _platform = Platform.getPlatformByName(platform)                        simulation = app.Simulation(            complex_structure.topology, complex_system, integrator, platform=_platform)               simulation.context.setPositions(complex_structure.positions)                positions = simulation.context.getState(            getPositions=True).getPositions()                        return OpenFFSimulation(simulation, positions,len(protein.openff_structure.atoms), integrator, flexible_side_chains, solvent )            def openff_minimiser(mols, ACO_object):                copy_of_coords = ACO_object.complex_system.positions.copy()        pos_idx = ACO_object.complex_system.num_protein_atoms        min_mols = []                        for mol in mols:            mol_hs = AddHs(mol, addCoords=True)            min_mols.append(mol_hs)            mol_pos = mol_hs.GetConformer().GetPositions()            num_atoms = mol_hs.GetNumAtoms()                        for num in range(num_atoms):                n_vec = vec3.Vec3(                    x=mol_pos[num][0] / 10, y=mol_pos[num][1] / 10, z=mol_pos[num][2] / 10)                n_quant = unit.quantity.Quantity(value=n_vec, unit=unit.nanometer)                ACO_object.complex_system.positions[pos_idx + num] = n_quant                            pos_idx += num_atoms                    ACO_object.complex_system.simulation.context.setPositions(ACO_object.complex_system.positions)        ACO_object.complex_system.simulation.minimizeEnergy()                positions = ACO_object.complex_system.simulation.context.getState(            getPositions=True).getPositions()                        pos_idx = ACO_object.complex_system.num_protein_atoms                        for mol in min_mols:                        conf = mol.GetConformer()                        for num in range(mol.GetNumAtoms()):                # convert back from nanometers to amstrong                x = round(positions[pos_idx + num].x, 4) * 10                y = round(positions[pos_idx + num].y, 4) * 10                z = round(positions[pos_idx + num].z, 4) * 10                conf.SetAtomPosition(num, Point3D(x, y, z))            pos_idx += mol.GetNumAtoms()                new_positions = positions.copy()        ACO_object.complex_system.simulation.context.setPositions(            copy_of_coords)        min_mols = [Chem.RemoveHs(i) for i in min_mols]        return min_mols, new_positions        def get_positions(simulation):        return simulation.context.getState(getPositions=True).getPositions()        def set_positions(complex_system, positions):        #change back once you know what is happening        if isinstance(positions[0], vec3.Vec3):            for idx, pos in enumerate(positions):                n_quant = unit.quantity.Quantity(value=pos, unit=unit.nanometer)                complex_system.positions[idx] = n_quant        complex_system.simulation.context.setPositions(complex_system.positions)                def simulated_anneling(complex_system,                           solution,                           missing_res = None,                           out_file  = './',                           cycles = 4,                           start_temp = 0,                           norm_temp = 300,                           top_temp = 315,                           temperature_step = 1,                           pressure = 1,                           barostatInterval = 10,                           initial_heating_interval = 10,                           heating_interval = 100,                           steps = 1000,                           aco_object = None,                           difference_map = None):                    #need to make an out_path !!!        copy_positions = copy.deepcopy(complex_system.positions)                OpenFFTools.set_positions(complex_system, solution.protein_positions)        asd = OpenFFTools.get_positions(complex_system.simulation)                        solutions = OpenFFTools._simulated_anneling(complex_system,                                                    cycles = cycles,                                                    start_temp = start_temp,                                                    norm_temp = norm_temp,                                                    top_temp = top_temp,                                                    temperature_step = temperature_step,                                                    pressure = pressure,                                                    barostatInterval = barostatInterval,                                                    initial_heating_interval= initial_heating_interval,                                                    heating_interval = heating_interval,                                                    steps = steps)                        all_refined_solutions = []        for num, sol in enumerate(solutions):            out = f'{out_file}_cycle_{num + 1}.pdb'                        OpenFFTools.write_complex_system(sol, complex_system.simulation.topology, out, missing_res = missing_res)                    #get the ChemEM score.            if aco_object is not None:                copy_protein = aco_object.protein                copy_distance_matrix = copy.deepcopy(aco_object.distance_matrix)                                off_mols = OpenFFTools.extract_mol(sol, aco_object.complex_system.num_protein_atoms, aco_object.initial_mols)                off_mols = [Chem.RemoveHs(i) for i in off_mols]                sdf_out_base = f'{out_file}_cycle_{num + 1}_ligand_'                                for lig_num, mol in enumerate(off_mols):                    sdf_out = f'{sdf_out_base}{lig_num + 1}.sdf'                    RDTools.write_to_sdf(mol, sdf_out)                                new_pos = []                for key in aco_object.distance_matrix.position_keys:                    if key.startswith('L'):                        continue                    pos = aco_object.protein.__chemem_conversion_keys__[key]                    new_pos.append([round(sol[pos].x * 10, 3), round(sol[pos].y * 10, 3), round(sol[pos].z * 10, 3)])                                        #residue = !!!HERE                                                for pos, ele in zip(mol.GetConformer().GetPositions(), mol.GetAtoms()):                    if ele.GetSymbol() != 'H':                        new_pos.append(pos)                                new_pos = np.array(new_pos)                aco_object.distance_matrix.update_positions(new_pos,0)                                new_protein = aco_object.protein.update_positions([[round(i.x * 10, 3), round(i.y * 10, 3), round(i.z * 10, 3)] for i in sol])                                aco_object.protein = new_protein                                 chemem_score = ScoringFunctions.ChemEM_score(off_mols, aco_object, difference_map = difference_map)                                all_refined_solutions.append(PostRefinedSolution(ligand_id = out_file.split('/')[-1],                                                                 cycle = num + 1,                                                                 chemem_score = chemem_score,                                                                 refined_solution = off_mols,                                                                 off_positions = sol,                                                                 chemem_protein = new_protein,                                                                 _dist_matrix = copy.deepcopy(aco_object.distance_matrix)))                                                aco_object.protein = copy_protein                 aco_object.distance_matrix = copy_distance_matrix                                          OpenFFTools.set_positions(complex_system, copy_positions)                   return all_refined_solutions    def extract_mol(solution, num_protein_atoms, initial_mols):                        new_mols = []        start_idx = num_protein_atoms        for mol in initial_mols:            copy_mol = Chem.Mol(mol)            copy_mol = Chem.AddHs(copy_mol)            conf = copy_mol.GetConformer()            for idx in range(start_idx, start_idx + copy_mol.GetNumAtoms()):                pos = solution[idx]                x,y,z = round(pos.x * 10, 3), round(pos.y * 10, 3),  round(pos.z * 10, 3)                rdkit_idx = idx - start_idx                conf.SetAtomPosition(rdkit_idx, Point3D(x, y, z))            start_idx += copy_mol.GetNumAtoms()            new_mols.append(copy_mol)                return new_mols                                def _simulated_anneling(complex_system,                            cycles = 4,                            start_temp = 0,                            norm_temp = 300,                            top_temp = 315,                            temperature_step = 1,                            pressure = 1,                            barostatInterval = 10,                            initial_heating_interval = 10,                            heating_interval = 100,                            steps = 1000,                            ):                        try:            complex_system.simulation.minimizeEnergy()                    except:                       return [complex_system.positions]                        start_temp = start_temp  * unit.kelvin        norm_temp = norm_temp * unit.kelvin        top_temp = top_temp * unit.kelvin        temperature_step = temperature_step * unit.kelvin        pressure = pressure * unit.atmosphere        barostat = MonteCarloBarostat(pressure, start_temp, barostatInterval)        complex_system.simulation.context.setVelocitiesToTemperature(start_temp)                all_positions = []                print('initial heating of system')        for temp in np.arange(start_temp.value_in_unit(unit.kelvin),norm_temp.value_in_unit(unit.kelvin),temperature_step.value_in_unit(unit.kelvin)):            if temp % 10 == 0:                print(f'\rcurrent temperature: {temp}', sep='' ,end='', flush=True)                        complex_system.integrator.setTemperature(temp* unit.kelvin)                barostat.setDefaultTemperature(temp* unit.kelvin)            complex_system.simulation.step(initial_heating_interval)                        try:                    for iteration in range(cycles):                                            print(f'\nsimulating iteration {iteration + 1 } of { cycles }')                complex_system.simulation.step(steps)                                print('heating system to top temperature')                for temp in np.arange(norm_temp.value_in_unit(unit.kelvin),top_temp.value_in_unit(unit.kelvin),temperature_step.value_in_unit(unit.kelvin)):                    complex_system.integrator.setTemperature(temp*unit.kelvin)                    barostat.setDefaultTemperature(temp*unit.kelvin)                    complex_system.simulation.step(heating_interval)                                print('holding top temperature')                complex_system.simulation.step(steps)                                print('cooling system to end temperature')                                for temp in np.arange(top_temp.value_in_unit(unit.kelvin), norm_temp.value_in_unit(unit.kelvin),-temperature_step.value_in_unit(unit.kelvin)):                    print(f'\rcurrent temperature: {temp}', sep='' ,end='', flush=True)                    complex_system.integrator.setTemperature(temp*unit.kelvin)                    barostat.setDefaultTemperature(temp*unit.kelvin)                    complex_system.simulation.step(heating_interval)                                    print('\nfinal equilibration')                complex_system.simulation.step(200)                complex_system.simulation.minimizeEnergy()                                                #write at each iteration only to save on using too much memory!!                positions = complex_system.simulation.context.getState(getPositions=True).getPositions()                positions = copy.deepcopy(positions)                all_positions.append(positions)                                            return all_positions                except:                                        if len(all_positions) > 0:                                return                         else:                                return[complex_system.positions]        