import osimport sysimport jsonimport timeimport randomimport numpy as npimport tempfileimport copyfrom dataclasses import dataclass, fieldfrom scipy.ndimage import gaussian_filterfrom scipy.spatial.distance import euclideanfrom ChemEM.tools.rdtools import RDToolsfrom ChemEM.scoring_functions import ScoringFunctionsfrom ChemEM.tools.math import MathToolsfrom rdkit import Chemfrom rdkit.Geometry import Point3Dfrom rdkit.Chem.rdmolops import AddHsfrom rdkit import Chemfrom openff.toolkit.topology import Moleculefrom openff.toolkit.typing.engines.smirnoff import ForceFieldimport parmedfrom openmm import MonteCarloBarostat, XmlSerializer, app, unit, CustomCompoundBondForce, Continuous3DFunction, vec3from openmm.app import HBonds, NoCutoff, PDBFile, Modeller, Topologyfrom openmm.unit.quantity import Quantityfrom openmm import LangevinIntegrator, Platformfrom pdbfixer import PDBFixerclass OpenFFSimulation():    def __init__(self, simulation,                  positions,                  protein_atoms,                  integrator,                 flexible_side_chains,                 solvent):        self.simulation = simulation        self.positions = positions        self.num_protein_atoms = protein_atoms        self.integrator = integrator        self.flexible_side_chains = flexible_side_chains        self.solvent = solvent        @dataclassclass PostRefinedSolution:    ligand_id : str    cycle : int    chemem_score : float     refined_solution :  object = field(repr = False)    off_positions : object  = field(repr = False)    chemem_protein : object  = field(repr = False)    _dist_matrix : object  = field(repr = False)    class OpenFFTools():        def load_ligand_structure(molecule):                        mol = Chem.Mol(molecule)                if getattr(sys, 'frozen', False):            # If bundled executable, use the temporary directory path set by PyInstaller            base_path = sys._MEIPASS            path = os.path.join(base_path, '__tmp__')                                else:            # If running as a script, use the script's directory            #base_path = os.path.dirname(os.path.abspath(__file__))            path = f'{os.path.dirname(os.path.abspath(__file__))}/__tmp__/'                tmp_file =f'{ path  }tmp_lig_{time.time()}{random.randint(0,1000000)}.sdf'        RDTools.write_to_sdf(mol, tmp_file)        ligand_off_molecule = Molecule(tmp_file)        os.remove(tmp_file)        force_field = ForceField("openff_unconstrained-2.0.0.offxml")        ligand_system = force_field.create_openmm_system(            ligand_off_molecule.to_topology())                tmp_file = tmp_file.replace('.sdf', '.pdb')        mol = AddHs(mol, addCoords=True)        Chem.MolToPDBFile(mol, tmp_file)        ligand_pdbfile = PDBFile(tmp_file)        ligand_structure = parmed.openmm.load_topology(            ligand_pdbfile.topology, ligand_system, xyz=ligand_pdbfile.positions        )        os.remove(tmp_file)        return ligand_structure            def load_protein_structure(protein_file):                        try:            receptor_pdbfile = PDBFile(protein_file)                    # Load the AMBER protein force field through OpenMM.            omm_forcefield = app.ForceField("amber14-all.xml", "implicit/gbn2.xml")                    # Parameterize the protein.            receptor_system = omm_forcefield.createSystem(receptor_pdbfile.topology)            missing_res = None            # Convert the protein System into a ParmEd Structure.            receptor_structure = parmed.openmm.load_topology(                receptor_pdbfile.topology, receptor_system, xyz=receptor_pdbfile.positions            )        except ValueError:                        receptor_pdbfile, missing_res = OpenFFTools.pdb_fixer(protein_file)                        omm_forcefield = app.ForceField("amber14-all.xml", "implicit/gbn2.xml")            #modeller = Modeller(receptor_pdbfile.topology, receptor_pdbfile.positions)            #modeller.addHydrogens(omm_forcefield, pH=7.0)            receptor_system = omm_forcefield.createSystem(receptor_pdbfile.topology)                        # Convert the protein System into a ParmEd Structure.            receptor_structure = parmed.openmm.load_topology(                receptor_pdbfile.topology, receptor_system, xyz=receptor_pdbfile.positions            )                            chem_em_residue_data , openff_chemem_conversion_keys = OpenFFTools.openFF_structure_to_ChemEM_residues(receptor_structure.residues)                return  chem_em_residue_data , receptor_structure, openff_chemem_conversion_keys  , {v : k for k, v in openff_chemem_conversion_keys.items()}, missing_res        def pdb_fixer(protein_file):        fixer = PDBFixer(protein_file)                residues_before = list(fixer.topology.residues())        res_before = [(i.chain.id, i.id) for i in residues_before]        fixer.findMissingResidues()        #fixer.findNonstandardResidues()        #fixer.replaceNonstandardResidues()        #fixer.removeHeterogens(True)        fixer.findMissingAtoms()        fixer.addMissingAtoms()        fixer.addMissingHydrogens(7.0)        residues_after = list(fixer.topology.residues())        res_after = [(i.chain.id, i.id) for i in residues_after]                missing_res = OpenFFTools.get_missing_residue_keys(fixer)        #missing_res = [i for i in res_after if i not in res_before]        #os.join()                        with tempfile.NamedTemporaryFile(mode='w+', delete=True) as temp:            PDBFile.writeFile(fixer.topology, fixer.positions,temp)            temp.flush()            receptor_pdbfile = PDBFile(temp.name)                        return receptor_pdbfile, missing_res         def get_missing_residue_keys(fixer):        missing_residues = fixer.missingResidues        missing_res_keys = list(missing_residues)        missing_res_keys.sort(key=lambda x: (x[0], x[1]))        index_shift = [0] * len(list(fixer.topology.chains()))        new_keys = []        for key in missing_res_keys:            chainIndex, residueIndex = key            num_missing_residues = len(missing_residues[key])            adjusted_residueIndex = residueIndex + index_shift[chainIndex]            for i in range(num_missing_residues):                new_keys.append((chainIndex, adjusted_residueIndex + i))                                    index_shift[chainIndex] += num_missing_residues                    return new_keys                def openFF_structure_to_ChemEM_residues(residues):                        path = os.path.dirname(os.path.abspath(__file__))        openff_chemem_conversion_keys = {}        mols = []        for res in residues:            mol = RDTools.mol_from_sdf(f'{path}/amino_acids/{res.name}.sdf')            mol, openff_scoring_conversion_idx = OpenFFTools.openFF_to_ChemEM_residue( mol, res, path)            mols.append(mol)            openff_chemem_conversion_keys.update(openff_scoring_conversion_idx)               return mols, openff_chemem_conversion_keys             def openFF_to_ChemEM_residue(mol, residue, path):                json_path = f'{path}/amino_acids/{residue.name}.json'        with open(json_path, 'r') as f:            ligand_data = json.load(f)                json_hydrogen_path = f'{path}/amino_acids/{residue.name}_hydrogens.json'        with open(json_hydrogen_path, 'r') as f:            ligand_hydrogen_data = json.load(f)                           conf = mol.GetConformer()                hydrogens = {i: {} for i in ligand_data}                residue_number = residue.number        residue_name = residue.name        residue_chain = residue.chain        residue_key = f'{residue_number}:{residue_chain}'        residue_conversion_keys = {}                        for atom in residue.atoms:            #assign hydrogens to atoms            #add this atom to the mol later on            if atom.name == 'OXT':                continue                        opennmm_scoring_conversion_idx = atom._idx            atom_key = f'{residue_key}.{atom.name}'            #This may change!!#now included hydrogens!!            residue_conversion_keys[opennmm_scoring_conversion_idx] = atom_key                                    if atom.name.startswith('H'):                pos = [atom.xx, atom.xy, atom.xz]                hydrogens[ligand_hydrogen_data[atom.name]][atom.name] = pos                                continue                        x, y, z = [atom.xx, atom.xy, atom.xz]            new_coord_index = ligand_data[atom.name]            conf.SetAtomPosition(new_coord_index, Point3D(x, y, z))                residue_data = {'name' : residue_name, 'number' : residue_number, 'chain' : residue_chain, 'key': residue_key,                         'mol' : mol, 'hydrogens' : hydrogens, 'atom_indexs' : ligand_data}                return residue_data, residue_conversion_keys                def write_complex_system(positions, topology, out_file, missing_res = None):                new_topology = Topology()        new_positions = []        atoms_to_remove = []        old_to_new_atoms = {}                if missing_res is None:            new_positions = positions            new_topology = topology        else:            for chain in list(topology.chains()):                new_chain = new_topology.addChain(chain.id)                for num,residue in enumerate(list(chain.residues())):                    key = (chain.index, num)                                        #key = (chain.id, residue.id)                    if key not in missing_res:                        new_residue = new_topology.addResidue(residue.name, new_chain, residue.id, residue.insertionCode)                        for atom in residue.atoms():                            new_atom = new_topology.addAtom(atom.name, atom.element, new_residue)                                                elif key in missing_res:                                                for atom in residue.atoms():                            atoms_to_remove.append(atom.index)                        new_positions = copy.deepcopy(positions)                        for index in sorted(atoms_to_remove, reverse=True):                del new_positions[index]                        with open(out_file, 'w') as f:            PDBFile.writeFile(new_topology, new_positions, f)                                                            def write_complex_system_old(positions,topology,out_file, missing_res = None):                topology = copy.deepcopy(topology)        atoms_to_remove = []        for chain in list(topology.chains()):                                    for num,residue in enumerate(list(chain.residues())):                key = (chain.index, num)                if key in missing_res:                    for atom in residue.atoms():                        atoms_to_remove.append(atom.index)                                                    pass            def get_missing_res(missing_res):        new_missing_res = []        for key in missing_res:            chain = key[0]            start_idx  = key[1]            for i in missing_res[key]:                if (chain, start_idx) in new_missing_res:                    print('HERER')                    new_missing_res.append((chain, start_idx))                    start_idx += 1                                return new_missing_res                        def get_global_k(resolution):        if resolution < 3.0:            return 75.0                else:            return 25.0                    def compute_map_field(m, blur=0, d3d_func=None):        #f = CustomCompoundBondForce(1,'')        #     d3d_func = Discrete3DFunction(*m.fullMap.shape, m.fullMap.ravel().copy())        morg = np.array(m.origin)[::-1] - m.apix/2        mdim = np.array(m.box_size())*m.apix        mmax = morg+mdim        mod_m = gaussian_filter(m.fullMap, blur)        minmaxes = np.array(list(zip(morg/10, mmax/10))).ravel()                if d3d_func is None:            d3d_func = Continuous3DFunction(                *mod_m.shape, mod_m.ravel(order="F"), *minmaxes)        else:            d3d_func.setFunctionParameters(                *mod_m.shape, mod_m.ravel(order="F"), *minmaxes)                return d3d_func    def map_potential_force_field(m, global_k, blur=0):                 f = CustomCompoundBondForce(1, '')        d3d_func = OpenFFTools.compute_map_field(m, blur)        f.addTabulatedFunction(name='map_potential', function=d3d_func)        f.addGlobalParameter(name='global_k', defaultValue=global_k)        f.addPerBondParameter(name='individual_k')        f.setEnergyFunction('-global_k * individual_k * map_potential(z1,y1,x1)')        return f                 def pin_force():        expr = "pin_k * ((x1 - x0)^2 + (y1 - y0)^2 + (z1 - z0)^2)"        f = CustomCompoundBondForce(1, expr)        f.addPerBondParameter("pin_k")        f.addPerBondParameter("x0")        f.addPerBondParameter("y0")        f.addPerBondParameter("z0")        return f        def pin_atoms(idx_to_pin, struct, pin_k=500):        pin_f = OpenFFTools.pin_force()        for atom_index in idx_to_pin:            atm = struct.atoms[atom_index]            x0, y0, z0 = Quantity(                value=[atm.xx, atm.xy, atm.xz], unit=unit.angstrom)            #x0, y0, z0 = atm.xx, atm.xy, atm.xz            pin_f.addBond([atom_index], [pin_k, x0, y0, z0])        return pin_f        def get_binding_site_idx(struct, centroid, radius):        aminoacids = ["ALA", "ARG", "ASN", "ASP", "CYS", "GLU", "GLN", "GLY", "HIS",                      "ILE", "LEU", "LYS", "MET", "PHE", "PRO", "SER", "THR", "TRP", "TYR", "VAL"]        ligand_name = ['NA', 'MG']        exc_atms = []        inc_atms = []        for atm in struct.atoms:            atm_idx = atm.idx            if atm.residue.name in aminoacids or atm.residue.name in ligand_name:                exc_atms.append(atm_idx)            elif atm.residue.name in ligand_name:                exc_atms.append(atm_idx)            else:                inc_atms.append(atm_idx)        return exc_atms, inc_atms        def get_binding_site_idx_flexible(struct, centroids, radius, map_bounds):        #raidus = 15.0                inc_res = []        exc_res = []        aminoacids = ["ALA", "ARG", "ASN" ,"ASP", "CYS", "GLU","GLN", "GLY", "HIS", "ILE","LEU", "LYS", "MET", "PHE", "PRO", "SER","THR", "TRP", "TYR","VAL"]        backbone_atoms = ['N', 'CA','C', 'O', 'H', 'HA']        ligand_name = ['NA', 'MG']        d = []        for atm in struct.atoms:            atm_coord = [atm.xx,  atm.xy, atm.xz]                        if atm.residue.name not in aminoacids and atm.residue.name not in ligand_name:                if atm.residue.number not in inc_res:                    inc_res.append(atm.residue.number)               for centroid in centroids:                dist = MathTools.euclidean_distance(atm_coord, centroid)                #dist = euclidean(atm_coord, centroid)                                if dist  <= radius:                    d.append((dist, atm_coord, atm))                                    if atm.residue.number not in inc_res:                                inc_res.append(atm.residue.number)                                       exc_atms = []        inc_atms = []                        for atm in struct.atoms:            atm_idx = atm.idx                                    if atm.residue.number not in inc_res:                exc_atms.append(atm_idx)                                        elif atm.residue.name in ligand_name:                exc_atms.append(atm)                        elif atm.residue.name not in aminoacids:                inc_atms.append(atm_idx)                                        elif atm.residue.name in aminoacids and atm.name in backbone_atoms:                exc_atms.append(atm_idx)                            elif atm.residue.name in ligand_name:                exc_atms.append(atm_idx)                            elif map_bounds is None:                                inc_atms.append(atm_idx)                                            elif atm.xx < map_bounds[0] or atm.xx > map_bounds[1]:                exc_atms.append(atm_idx)                            elif atm.xy < map_bounds[2] or atm.xy > map_bounds[3]:                exc_atms.append(atm_idx)                            elif atm.xz < map_bounds[4] or atm.xz > map_bounds[5]:                exc_atms.append(atm_idx)                            else:                inc_atms.append(atm_idx)                return exc_atms, inc_atms                def openmm_complex_system(protein,                               ligands,                              centroid,                              dens_map = None,                              map_bounds = None,                              global_k = None,                              cutoff = 15.0,                              flexible_side_chains = False,                              solvent=False,                              platform = 'OpenCL',                              pin_k = 1000):                        complex_structure =  protein.openff_structure + ligands[0].openff_structure        for mol in ligands[1:]:            complex_structure += mol.openff_structure                # Convert the Structure to an OpenMM System in vacuum.        if solvent == True:            complex_system = complex_structure.createSystem(                nonbondedMethod=NoCutoff,                nonbondedCutoff=9.0 * unit.angstrom,                constraints=HBonds,                removeCMMotion=False,                implicitSolvent=app.GBn2            )        else:            complex_system = complex_structure.createSystem(                nonbondedMethod=NoCutoff,                nonbondedCutoff=9.0 * unit.angstrom,                constraints=HBonds,                removeCMMotion=False)                if flexible_side_chains == True:                    exc_atoms, inc_atoms = OpenFFTools.get_binding_site_idx_flexible(                complex_structure , centroid, cutoff, map_bounds)                                else:            exc_atoms, inc_atoms = OpenFFTools.get_binding_site_idx(                complex_structure , centroid, cutoff)                        force_group = 0        for force in complex_system.getForces():            force.setForceGroup(force_group)            force_group += 1                       if dens_map is not None:            #add map potential            copy_map = dens_map.copy()            c_level = dens_map.map_contour            copy_map.fullMap =  copy_map.fullMap * (copy_map.fullMap >= c_level)            copy_map.fullMap = copy_map.fullMap / np.amax(copy_map.fullMap)                        if global_k is None:                global_k = OpenFFTools.get_global_k(dens_map.resolution)                                                mp = OpenFFTools.map_potential_force_field(copy_map, global_k)            # add bonds to force field            for idx in inc_atoms:                mp.addBond([idx], [1.0])            # add force here potential for map            force_idx = complex_system.addForce(mp)            complex_system.getForce(force_idx).setForceGroup(force_group)            force_group += 1                # pin remaining atoms        p_force = OpenFFTools.pin_atoms(            exc_atoms, complex_structure, pin_k=pin_k)        pin_idx = complex_system.addForce(p_force)        complex_system.getForce(pin_idx).setForceGroup(force_group)                integrator = LangevinIntegrator(300*unit.kelvin, 1.0/unit.picoseconds,                                        1.0*unit.femtoseconds)                _platform = Platform.getPlatformByName(platform)                        simulation = app.Simulation(            complex_structure.topology, complex_system, integrator, platform=_platform)               simulation.context.setPositions(complex_structure.positions)                positions = simulation.context.getState(            getPositions=True).getPositions()                        return OpenFFSimulation(simulation, positions,len(protein.openff_structure.atoms), integrator, flexible_side_chains, solvent )            def openff_minimiser(mols, ACO_object):                copy_of_coords = ACO_object.complex_system.positions.copy()        pos_idx = ACO_object.complex_system.num_protein_atoms        min_mols = []                        for mol in mols:            mol_hs = AddHs(mol, addCoords=True)            min_mols.append(mol_hs)            mol_pos = mol_hs.GetConformer().GetPositions()            num_atoms = mol_hs.GetNumAtoms()                        for num in range(num_atoms):                n_vec = vec3.Vec3(                    x=mol_pos[num][0] / 10, y=mol_pos[num][1] / 10, z=mol_pos[num][2] / 10)                n_quant = unit.quantity.Quantity(value=n_vec, unit=unit.nanometer)                ACO_object.complex_system.positions[pos_idx + num] = n_quant                            pos_idx += num_atoms                    ACO_object.complex_system.simulation.context.setPositions(ACO_object.complex_system.positions)        ACO_object.complex_system.simulation.minimizeEnergy()                positions = ACO_object.complex_system.simulation.context.getState(            getPositions=True).getPositions()                        pos_idx = ACO_object.complex_system.num_protein_atoms                        for mol in min_mols:                        conf = mol.GetConformer()                        for num in range(mol.GetNumAtoms()):                # convert back from nanometers to amstrong                x = round(positions[pos_idx + num].x, 4) * 10                y = round(positions[pos_idx + num].y, 4) * 10                z = round(positions[pos_idx + num].z, 4) * 10                conf.SetAtomPosition(num, Point3D(x, y, z))            pos_idx += mol.GetNumAtoms()                new_positions = positions.copy()        ACO_object.complex_system.simulation.context.setPositions(            copy_of_coords)        min_mols = [Chem.RemoveHs(i) for i in min_mols]        return min_mols, new_positions        def get_positions(simulation):        return simulation.context.getState(getPositions=True).getPositions()        def set_positions(complex_system, positions):        #change back once you know what is happening        if isinstance(positions[0], vec3.Vec3):            for idx, pos in enumerate(positions):                n_quant = unit.quantity.Quantity(value=pos, unit=unit.nanometer)                complex_system.positions[idx] = n_quant        complex_system.simulation.context.setPositions(complex_system.positions)                def simulated_anneling(complex_system,                           solution,                           missing_res = None,                           out_file  = './',                           cycles = 4,                           start_temp = 0,                           norm_temp = 300,                           top_temp = 315,                           temperature_step = 1,                           pressure = 1,                           barostatInterval = 10,                           initial_heating_interval = 10,                           heating_interval = 100,                           steps = 1000,                           aco_object = None):                    #need to make an out_path !!!        copy_positions = copy.deepcopy(complex_system.positions)                OpenFFTools.set_positions(complex_system, solution.protein_positions)        asd = OpenFFTools.get_positions(complex_system.simulation)                        solutions = OpenFFTools._simulated_anneling(complex_system,                                                    cycles = cycles,                                                    start_temp = start_temp,                                                    norm_temp = norm_temp,                                                    top_temp = top_temp,                                                    temperature_step = temperature_step,                                                    pressure = pressure,                                                    barostatInterval = barostatInterval,                                                    initial_heating_interval= initial_heating_interval,                                                    heating_interval = heating_interval,                                                    steps = steps)                        all_refined_solutions = []        for num, sol in enumerate(solutions):            out = f'{out_file}_cycle_{num + 1}.pdb'                        OpenFFTools.write_complex_system(sol, complex_system.simulation.topology, out, missing_res = missing_res)                    #get the ChemEM score.            if aco_object is not None:                copy_protein = aco_object.protein                copy_distance_matrix = copy.deepcopy(aco_object.distance_matrix)                                off_mols = OpenFFTools.extract_mol(sol, aco_object.complex_system.num_protein_atoms, aco_object.initial_mols)                off_mols = [Chem.RemoveHs(i) for i in off_mols]                sdf_out_base = f'{out_file}_cycle_{num + 1}_ligand_'                                for lig_num, mol in enumerate(off_mols):                    sdf_out = f'{sdf_out_base}{lig_num + 1}.sdf'                    RDTools.write_to_sdf(mol, sdf_out)                                new_pos = []                for key in aco_object.distance_matrix.position_keys:                    if key.startswith('L'):                        continue                    pos = aco_object.protein.__chemem_conversion_keys__[key]                    new_pos.append([round(sol[pos].x * 10, 3), round(sol[pos].y * 10, 3), round(sol[pos].z * 10, 3)])                                        #residue = !!!HERE                                                for pos, ele in zip(mol.GetConformer().GetPositions(), mol.GetAtoms()):                    if ele.GetSymbol() != 'H':                        new_pos.append(pos)                                new_pos = np.array(new_pos)                aco_object.distance_matrix.update_positions(new_pos,0)                                new_protein = aco_object.protein.update_positions([[round(i.x * 10, 3), round(i.y * 10, 3), round(i.z * 10, 3)] for i in sol])                                aco_object.protein = new_protein                                 chemem_score = ScoringFunctions.ChemEM_score(off_mols, aco_object, difference_map = aco_object._difference_map)                                all_refined_solutions.append(PostRefinedSolution(ligand_id = out_file.split('/')[-1],                                                                 cycle = num + 1,                                                                 chemem_score = chemem_score,                                                                 refined_solution = off_mols,                                                                 off_positions = sol,                                                                 chemem_protein = new_protein,                                                                 _dist_matrix = copy.deepcopy(aco_object.distance_matrix)))                                aco_object.protein = copy_protein                 aco_object.distance_matrix = copy_distance_matrix                                          OpenFFTools.set_positions(complex_system, copy_positions)                   return all_refined_solutions    def extract_mol(solution, num_protein_atoms, initial_mols):                        new_mols = []        start_idx = num_protein_atoms        for mol in initial_mols:            copy_mol = Chem.Mol(mol)            copy_mol = Chem.AddHs(copy_mol)            conf = copy_mol.GetConformer()            for idx in range(start_idx, start_idx + copy_mol.GetNumAtoms()):                pos = solution[idx]                x,y,z = round(pos.x * 10, 3), round(pos.y * 10, 3),  round(pos.z * 10, 3)                rdkit_idx = idx - start_idx                conf.SetAtomPosition(rdkit_idx, Point3D(x, y, z))            start_idx += copy_mol.GetNumAtoms()            new_mols.append(copy_mol)                return new_mols                                def _simulated_anneling(complex_system,                            cycles = 4,                            start_temp = 0,                            norm_temp = 300,                            top_temp = 315,                            temperature_step = 1,                            pressure = 1,                            barostatInterval = 10,                            initial_heating_interval = 10,                            heating_interval = 100,                            steps = 1000,                            ):                        try:            complex_system.simulation.minimizeEnergy()                    except:                       return [complex_system.positions]                        start_temp = start_temp  * unit.kelvin        norm_temp = norm_temp * unit.kelvin        top_temp = top_temp * unit.kelvin        temperature_step = temperature_step *unit.kelvin        pressure = pressure * unit.atmosphere        barostat = MonteCarloBarostat(pressure, start_temp, barostatInterval)        complex_system.simulation.context.setVelocitiesToTemperature(start_temp)                all_positions = []                print('initial heating of system')        for temp in np.arange(start_temp.value_in_unit(unit.kelvin),norm_temp.value_in_unit(unit.kelvin),temperature_step.value_in_unit(unit.kelvin)):            if temp % 10 == 0:                print(f'\rcurrent temperature: {temp}', sep='' ,end='', flush=True)                        complex_system.integrator.setTemperature(temp* unit.kelvin)            barostat.setDefaultTemperature(temp* unit.kelvin)            complex_system.simulation.step(initial_heating_interval)                        try:                    for iteration in range(cycles):                                            print(f'\nsimulating iteration {iteration + 1 } of { cycles }')                complex_system.simulation.step(steps)                                print('heating system to top temperature')                for temp in np.arange(norm_temp.value_in_unit(unit.kelvin),top_temp.value_in_unit(unit.kelvin),temperature_step.value_in_unit(unit.kelvin)):                    complex_system.integrator.setTemperature(temp*unit.kelvin)                    barostat.setDefaultTemperature(temp*unit.kelvin)                    complex_system.simulation.step(heating_interval)                                print('holding top temperature')                complex_system.simulation.step(1000)                                print('cooling system to end temperature')                                for temp in np.arange(top_temp.value_in_unit(unit.kelvin), norm_temp.value_in_unit(unit.kelvin),-temperature_step.value_in_unit(unit.kelvin)):                    print(f'\rcurrent temperature: {temp}', sep='' ,end='', flush=True)                    complex_system.integrator.setTemperature(temp*unit.kelvin)                    barostat.setDefaultTemperature(temp*unit.kelvin)                    complex_system.simulation.step(heating_interval)                                    print('\nfinal equilibration')                complex_system.simulation.step(200)                complex_system.simulation.minimizeEnergy()                                                #write at each iteration only to save on using too much memory!!                positions = complex_system.simulation.context.getState(getPositions=True).getPositions()                positions = copy.deepcopy(positions)                all_positions.append(positions)                                            return all_positions                except:                                        if len(all_positions) > 0:                                return                         else:                                return[complex_system.positions]        