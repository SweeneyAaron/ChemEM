import mathimport numpy as npimport pdb as pythondbfrom scipy.ndimage import labelfrom scipy.fftpack import fftn, ifftnfrom scipy.ndimage import fourier_gaussian, gaussian_filter from scipy.fftpack import (    ifftn,    fftshift,    ifftshift,)from TEMPy.protein.scoring_functions import StructureBlurrer, ScoringFunctionsfrom TEMPy.map_process.map_filters import Filterfrom TEMPy.maps.em_map import Mapimport pyfftwclass MapTools():        def get_mi_weight(resolution):        if resolution <= 5.0:            return 50         elif resolution > 5.0:            return 10                def get_map_bounds(dens_map, pad = 0.0):        if dens_map is None:            return None                if  isinstance(dens_map.apix, np.ndarray):            map_bounds = [dens_map.x_origin() + pad, (dens_map.x_origin() + (dens_map.x_size() * round(dens_map.apix[0], 2))) - pad,                           dens_map.y_origin() + pad, (dens_map.y_origin() + (dens_map.y_size() * round(dens_map.apix[1], 2))) - pad,                          dens_map.z_origin() + pad, (dens_map.z_origin() + (dens_map.z_size() * round(dens_map.apix[2], 2))) - pad]        else:            map_bounds = [dens_map.x_origin() + pad, (dens_map.x_origin() + (dens_map.x_size() * dens_map.apix)) - pad,                           dens_map.y_origin() + pad, (dens_map.y_origin() + (dens_map.y_size() * dens_map.apix)) - pad,                          dens_map.z_origin() + pad, (dens_map.z_origin() + (dens_map.z_size() * dens_map.apix)) - pad]                return map_bounds            def get_map_segement(densmap, box_limits, threshold = 0.0):                x_min = math.ceil( (box_limits[0] - densmap.x_origin()) / densmap.apix[0] )        x_max = round((box_limits[1] - densmap.x_origin()) / densmap.apix[0]  )                y_min = math.ceil( (box_limits[2] - densmap.x_origin()) / densmap.apix[1] )        y_max = round((box_limits[3] - densmap.x_origin()) / densmap.apix[1]  )                z_min = math.ceil( (box_limits[4] - densmap.x_origin()) / densmap.apix[2] )        z_max = round((box_limits[5] - densmap.x_origin()) / densmap.apix[2]  )                new_map = densmap.copy()        new_map.fullMap = new_map.fullMap[z_min:z_max, y_min:y_max, x_min:x_max]                                x_origin = new_map.x_origin() + (x_min * new_map.apix[0])        y_origin = new_map.y_origin() + (y_min * new_map.apix[1])        z_origin = new_map.z_origin() + (z_min * new_map.apix[2])        new_map.origin = (x_origin, y_origin, z_origin)        return new_map        def difference_map(densmap,                       molecule,                       resolution,                       thr1=None,                       thr2=None,                       apix=None,                       contour_mask = True,                       msk = False,                       scale = True,                       filt = True,                       dust = True,                        softdust = True,                       sw = 0.02,                       randsize =  0.2 ):                #emmap1 = dnesmap, emmap2 = mdl map                emmap1, emmap2, c1, c2, refsc = MapTools._difference_map_input(densmap, molecule, resolution, thr1, thr2, t=1.5)                #main calculation        #whether to shift density to positive values        c1 = (c1 - emmap1.min())        c2 = (c2 - emmap2.min())                emmap1.fullMap = (emmap1.fullMap - emmap1.min())        emmap2.fullMap = (emmap2.fullMap - emmap2.min())                #find a common box to hold both maps            #spacing = max(emmap1.apix[0],emmap2.apix[0]) #Hmmm TODO!!!                if sum(emmap1.apix) > sum(emmap2.apix):            spacing = emmap1.apix        else:            spacing = emmap2.apix                    #pythondb.set_trace()        grid_shape, new_ori = emmap1._alignment_box(emmap2,spacing)            emmap_1 = emmap1.copy()        emmap_2 = emmap2.copy()                if msk:            emmap1.fullMap = emmap1._soft_mask(c1)            emmap2.fullMap = emmap2._soft_mask(c2)                    if scale:            emmap_1.fullMap, emmap_2.fullMap = MapTools._amplitude_match(emmap1,emmap2,0,0,sw,0,0,resolution,lpfiltb=filt,lpfilta=False,ref=refsc)                    #resample scaled maps to common grid            if apix == None:            spacing = [resolution*0.33, resolution*0.33, resolution*0.33]        else:            spacing = apix                apix_ratio = emmap_1.apix/spacing        diff1 = emmap_1._interpolate_to_grid(grid_shape,spacing,new_ori,1)        diff2 = emmap_2._interpolate_to_grid(grid_shape,spacing,new_ori,1)                # get mask inside contour for the initial maps        emmap_1.fullMap = (emmap1.fullMap>c1)*1.0        emmap_2.fullMap = (emmap2.fullMap>c2)*1.0                #interpolate masks into common grid        mask1 = emmap_1._interpolate_to_grid(grid_shape,spacing,new_ori,1,'zero')        mask2 = emmap_2._interpolate_to_grid(grid_shape,spacing,new_ori,1,'zero')        mask1.fullMap = mask1.fullMap > 0.1        mask2.fullMap = mask2.fullMap > 0.1                #min of minimums in the two scaled maps        min1 = diff1.min()        min2 = diff2.min()        min_scaled_maps = min(min1,min2)        #shift to positive values        diff1.fullMap = diff1.fullMap - min_scaled_maps        diff2.fullMap = diff2.fullMap - min_scaled_maps                #range of values in the scaled maps        min1 = np.amin(diff1.fullMap[mask1.fullMap])        diffc1 = min1+0.10*(np.amax(diff1.fullMap)-min1)        #print diffc1,min1,np.amax(diff1.fullMap), c1, c2        min2 = np.amin(diff2.fullMap[mask2.fullMap])        diffc2 = min2+0.10*(np.amax(diff2.fullMap)-min2)                    #calculate difference        diff_map = diff1.copy()        diff1.fullMap = (diff1.fullMap - diff2.fullMap)        diff2.fullMap = (diff2.fullMap - diff_map.fullMap)                #dust filter        #apply mask to difference maps        if contour_mask:            diff1.fullMap = diff1.fullMap*(mask1.fullMap)            diff2.fullMap = diff2.fullMap*(mask2.fullMap)            if dust:                if softdust:                    diffc1 = min1 + 0.5 * (diffc1 - min1)                    diffc2 = min2 + 0.5 * (diffc2 - min2)                diff1.fullMap = diff1._label_patches(diffc1,prob=randsize)[0]                diff2.fullMap = diff2._label_patches(diffc2,prob=randsize)[0]                    #interpolate back to original grids                mask1 = diff1._interpolate_to_grid(emmap1.fullMap.shape, emmap1.apix ,emmap1.origin, 1,'zero')        mask2 = diff2._interpolate_to_grid(emmap2.fullMap.shape,emmap2.apix, emmap2.origin,1,'zero')                return mask1, mask2                            def _difference_map_input(densmap, molecule, resolution, thr1, thr2, t=1.5):                        c1 = MapTools.map_contour(densmap, t = t)                                if resolution > 20.0 :            mt = 2.0        elif resolution > 10.0:            mt = 1.0        elif resolution > 6.0:            mt = 0.5        else:            mt = 0.1                mdl_map = MapTools.blur_model(molecule,resolution, emmap=densmap)        c2 = MapTools.model_contour(mdl_map, t = mt)        refsc =True                return  densmap, mdl_map, c1, c2, refsc            def map_contour(m, t=-1.0):        '''         Calculates map contour        '''        emmap = m        c1 = None        if t != -1.0:            zeropeak,ave,sigma1 = emmap._peak_density()            if not zeropeak is None:                 c1 = zeropeak + (t * sigma1)            else:                c1 = 0.0            return c1        def model_contour(p_map,emmap = False,t=-1.0):        '''        calculates model contour        '''        c2 = None            if t != -1.0:            c2 = t*p_map.std()                return c2        def blur_model(mol,resolution,emmap=False):        '''        calculates map from rd mol        '''                prot = MapTools._prepare_molmap_input(mol)        densmap = MapTools.gaussian_blur(prot, resolution, emmap)        return densmap        def _prepare_molmap_input(mol,n_conf = 0):          molmap_input = []     atm_coords = mol.GetConformers()[n_conf].GetPositions()     atom_props = mol.GetAtoms()          for coord,prop in zip(atm_coords,atom_props):         x = float(coord[0])         y = float(coord[1])         z = float(coord[2])         atm_type = prop.GetSymbol()         mass = float(prop.GetMass())         atom_input = [atm_type,x,y,z,mass]         molmap_input.append(atom_input)     return molmap_input        def gaussian_blur(prot,                      resolution,                      densMap,                      sigma_coeff=0.356,                      normalise=True):                #x_s = int(densMap.x_size()*densMap.apix[0])        #y_s = int(densMap.y_size()*densMap.apix[1])        #z_s = int(densMap.z_size()*densMap.apix[2])                x_s, y_s, z_s = densMap.box_size()            newMap = densMap.copy()        newMap.fullMap = np.zeros((z_s, y_s, x_s))                #apix_x = round((densMap.apix[0] * densMap.x_size()) / x_s, 3)        #apix_y = round((densMap.apix[1] * densMap.y_size()) / y_s, 3)        #apix_z = round((densMap.apix[2] * densMap.z_size()) / z_s, 3)                #pythondb.set_trace()        #newMap.apix =np.array([apix_x, apix_y, apix_z])                sigma = sigma_coeff * resolution        newMap = MapTools.make_atom_overlay_map(newMap, prot) #add this                fou_map = fourier_gaussian(fftn(newMap.fullMap), sigma) #where does this come from        newMap.fullMap = np.real(ifftn(fou_map))        newMap = newMap.resample_by_box_size(densMap.box_size())        if normalise:            newMap = newMap.normalise()                newMap.update_header        return newMap     def make_atom_overlay_map(densMap, prot):               densMap = densMap.copy()        for atom in prot:            pos = MapTools.mapGridPosition(densMap, atom)            if pos:                densMap.fullMap[pos[2]][pos[1]][pos[0]] += pos[3]        return densMap     def mapGridPosition(densMap, atom):             origin = densMap.origin        apix = densMap.apix        box_size = densMap.box_size()        x_pos = int(round((atom[1] - origin[0]) / apix[0], 0)) #change x        y_pos = int(round((atom[2] - origin[1]) / apix[1], 0))        z_pos = int(round((atom[3] - origin[2]) / apix[2], 0))                if(           (box_size[2] > x_pos >= 0) and           (box_size[1] > y_pos >= 0) and           (box_size[0] > z_pos >= 0)        ):            return x_pos, y_pos, z_pos, atom[4]        else:            return 0        def split_density(dmap, struct = None, label_threshold_sigma = None, label_threshold = None):                '''        Takes in a density map and creates a mask of disconnected densities         each with a differernt value starting from 1.                Threshold: only consider density values greater than thee threshold        struct: scipy.ndimage.label structure 3 * 3 array to define connected density        '''                           if struct == None:            struct = np.array([[[1,1,1],[1,1,1],[1,1,1]],[[1,1,1],[1,1,1],[1,1,1]],[[1,1,1],[1,1,1],[1,1,1]]])                masked_map = dmap.copy()                if label_threshold_sigma is not None:            threshold = MapTools.map_contour(dmap, t = label_threshold_sigma)                elif label_threshold is not None:            print('THRESHOLD: ', label_threshold)                        threshold  = label_threshold        else:            threshold = 0.0        #pythondb.set_trace()        masked_map.fullMap = masked_map.fullMap > threshold                labels, num_features = label(masked_map.fullMap,structure = struct)        labeled_map = masked_map.copy()        labeled_map.fullMap = labels                return masked_map, labeled_map, num_features        def _tanh_lowpass(emmap, cutoff, fall=0.2):                cutoff = cutoff[0]        drop = math.pi/(2*float(cutoff)*float(fall))        cutoff = min(float(cutoff),0.5)        dist = Filter(emmap).make_fourier_shell(emmap.fullMap.shape, keep_shape = True)        emmap.fullMap = emmap.fullMap * (0.5*(np.tanh(drop*(dist+cutoff))-np.tanh(drop*(dist-cutoff))))    def _amplitude_match(map_1, map_2,                         shellmin,                         shellmax,                         step=0.005,                         c1=0,                         c2=0,                         reso=None,                         lpfiltb=False,                         lpfilta=False,                         ref=False,                         ):        """        Scale amplitudes to the average in each resolutions shell        Arguments:            *step : shell width (1/A)        """        pyfftw_flag = 1        try:            import pyfftw        except ImportError:            pyfftw_flag = 0                ft1, inputa1, outputa1 = MapTools._fft_planning(map_1)        ft2, inputa2, outputa2 = MapTools._fft_planning(map_2)                if reso is not None:            cutoff1 = map_1.apix / float(reso)            cutoff2 = map_2.apix / float(reso)            if lpfiltb and not lpfilta:                MapTools._tanh_lowpass(ft1, cutoff1, fall=0.2)                MapTools._tanh_lowpass(ft2, cutoff2, fall=0.2)                dist1 = map_1._make_fourier_shell(1)/map_1.apix[0]        dist2 = map_2._make_fourier_shell(1) / map_2.apix[0]        ft1_avg = []        ft2_avg = []        ft1_avg_new = []        lfreq = []        # select max spatial frequency to iterate to. low resolution map        maxlevel = 0.5 / np.max((map_1.apix[0], map_2.apix[0]), axis=0)        # loop over freq shells, shellwidth=0.005        # for x in arange(0,maxlevel+step,step):        nc = 0        x = 0.0        highlevel = x + step        while (x < maxlevel):            # print x,highlevel, maxlevel            # indices between upper and lower shell bound            fshells1 = ((dist1 < min(maxlevel, highlevel)) & (dist1 >= x))            # radial average            shellvec1 = ft1.fullMap[fshells1]            # indices between upper and lower shell bound            fshells2 = ((dist2 < min(maxlevel, highlevel)) & (dist2 >= x))            # radial average            shellvec2 = ft2.fullMap[fshells2]            abs1 = abs(shellvec1)            abs2 = abs(shellvec2)            ns1 = len(np.nonzero(abs1)[0])            ns2 = len(np.nonzero(abs2)[0])            if ns1 < 10 or ns2 < 10:                nc += 1                highlevel = min(maxlevel, x + (nc + 1) * step)                x = max(0.0, x - nc * step)                continue            else:                nc = 0            mft1 = np.mean(abs1)            mft2 = np.mean(abs2)            if mft1 == 0.0 and mft2 == 0.0:                continue            # sq of radial avg amplitude            ft1_avg.append(np.log10(np.mean(np.square(abs1))))            ft2_avg.append(np.log10(np.mean(np.square(abs2))))            # scale to amplitudes of the ref map            if ref:                if mft1 == 0.0:                    continue                ft1.fullMap[fshells1] = shellvec1 * (mft2 / mft1)            else:                # replace with avg amplitudes for the two maps                ft1.fullMap[fshells1] = shellvec1 * (mft2 + mft1) / (2 * mft1)                ft2.fullMap[fshells2] = shellvec2 * (mft2 + mft1) / (2 * mft2)            # new radial average (to check)            mft1 = np.mean(abs(ft1.fullMap[fshells1]))            ft1_avg_new.append(                np.log10(                    np.mean(                        np.square(abs(ft1.fullMap[fshells1]))                    )                )            )            lfreq.append(highlevel)            sampling_frq = highlevel            cutoff_freq = min((1.0 / reso) + 0.25, maxlevel)            # scale the rest and break after relevant frequencies            if sampling_frq > cutoff_freq:                fshells1 = (dist1 >= highlevel)                shellvec1 = ft1.fullMap[fshells1]                mft1 = np.mean(abs(shellvec1))                fshells2 = (dist2 >= highlevel)                shellvec2 = ft2.fullMap[fshells2]                mft2 = np.mean(abs(shellvec2))                if mft1 == 0.0 and mft2 == 0.0:                    break                ft1_avg.append(np.log10(np.mean(np.square(abs(shellvec1)))))                ft2_avg.append(np.log10(np.mean(np.square(abs(shellvec2)))))                if ref:                    if mft1 == 0.0:                        break                    ft1.fullMap[fshells1] = shellvec1*(mft2/mft1)                else:                    ft1.fullMap[fshells1] = shellvec1*(mft2+mft1)/(2*mft1)                    ft2.fullMap[fshells2] = shellvec2*(mft2+mft1)/(2*mft2)                mft1 = np.mean(abs(ft1.fullMap[fshells1]))                ft1_avg_new.append(                    np.log10(                        np.mean(                            np.square(abs(ft1.fullMap[fshells1]))                        )                    )                )                lfreq.append((highlevel + step / 2))                break            x = highlevel            highlevel = x + step        # low pass filter after?        # low pass filter before scaling        if reso is not None:            if lpfilta and not lpfiltb:                MapTools._tanh_lowpass(ft1, cutoff1, fall=0.2)                MapTools._tanh_lowpass(ft2, cutoff2,fall=0.2)                map1_filt = MapTools._fft_output(ft1, map_1, inputa1, outputa1)        map2_filt = MapTools._fft_output(ft2, map_2, inputa2, outputa2)                return map1_filt.fullMap, map2_filt.fullMap                    def _fft_output(ft1, emmap, inputa1, outputa1):                        pyfftw_flag = 1        try:            import pyfftw        except ImportError:            pyfftw_flag = 0        try:            if pyfftw_flag == 0:                raise ImportError                            ifft = pyfftw.FFTW(                inputa1,                outputa1,                direction='FFTW_BACKWARD',                axes=(0, 1, 2),                flags=['FFTW_ESTIMATE'],            )            inputa1[:, :, :] = ifftshift(ft1.fullMap)[:, :, :]            ifft()            map1_filt = Map(                outputa1.real.astype('float'),                emmap.origin,                emmap.apix,                emmap.filename,                emmap.header[:],            )        except Exception:            # use numpy ifft instead            map1_filt = emmap.copy()            map1_filt.fullMap = np.real(ifftn(ifftshift(ft1.fullMap)))                               return map1_filt            def _fft_planning(emmap):                pyfftw_flag = 1        try:            import pyfftw        except ImportError:            pyfftw_flag = 0                    try:            if pyfftw_flag == 0:                raise ImportError            inputa1 = pyfftw.n_byte_align_empty(                emmap.fullMap.shape,                16,                'complex128',            )            outputa1 = pyfftw.n_byte_align_empty(                emmap.fullMap.shape,                16,                'complex128',            )            fft = pyfftw.FFTW(                inputa1,                outputa1,                direction='FFTW_FORWARD',                axes=(0, 1, 2),                flags=['FFTW_ESTIMATE'],            )            inputa1[:, :, :] = emmap.fullMap[:, :, :]            fft()            ft1 = Map(                fftshift(outputa1),                emmap.origin,                emmap.apix,                emmap.filename,                emmap.header[:],            )        except Exception:            # use numpy fft instead            ft1 = emmap.fourier_transform()                return ft1, inputa1, outputa1        