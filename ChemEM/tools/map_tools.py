# This file is part of the ChemEM software.## Copyright (c) 2023 - Topf Group & Leibniz Institute for Virology (LIV),# Hamburg, Germany.## This module was developed by:#   Aaron Sweeney    <aaron.sweeney AT cssb-hamburg.de>import mathimport numpy as npfrom scipy.ndimage import labelfrom scipy.fftpack import fftn, ifftnfrom scipy.ndimage import fourier_gaussian, gaussian_filter from scipy.fftpack import (    ifftn,    fftshift,    ifftshift,)class MapTools():        def get_mi_weight(resolution):        if resolution <= 5.0:            return 100        elif resolution > 5.0:            return 20                def get_map_bounds(dens_map, pad = 0.0):        if dens_map is None:            return None                if  isinstance(dens_map.apix, np.ndarray):            map_bounds = [dens_map.x_origin + pad, (dens_map.x_origin + (dens_map.x_size * round(dens_map.apix[0], 2))) - pad,                           dens_map.y_origin + pad, (dens_map.y_origin + (dens_map.y_size * round(dens_map.apix[1], 2))) - pad,                          dens_map.z_origin + pad, (dens_map.z_origin + (dens_map.z_size * round(dens_map.apix[2], 2))) - pad]        else:            map_bounds = [dens_map.x_origin + pad, (dens_map.x_origin + (dens_map.x_size * dens_map.apix)) - pad,                           dens_map.y_origin + pad, (dens_map.y_origin + (dens_map.y_size * dens_map.apix)) - pad,                          dens_map.z_origin + pad, (dens_map.z_origin + (dens_map.z_size * dens_map.apix)) - pad]                return map_bounds            def get_map_segement(densmap, box_limits, threshold = 0.0):        x_min = math.ceil( (box_limits[0] - densmap.x_origin) / densmap.apix[0] )        x_max = round((box_limits[1] - densmap.x_origin) / densmap.apix[0]  )                y_min = math.ceil( (box_limits[2] - densmap.y_origin) / densmap.apix[1] )        y_max = round((box_limits[3] - densmap.y_origin) / densmap.apix[1]  )                z_min = math.ceil( (box_limits[4] - densmap.z_origin) / densmap.apix[2] )        z_max = round((box_limits[5] - densmap.z_origin) / densmap.apix[2]  )                                new_map = densmap.copy()                new_map.density_map = new_map.density_map[z_min:z_max, y_min:y_max, x_min:x_max]        x_origin = new_map.x_origin + (x_min * new_map.apix[0])        y_origin = new_map.y_origin + (y_min * new_map.apix[1])        z_origin = new_map.z_origin + (z_min * new_map.apix[2])        new_map.origin = (x_origin, y_origin, z_origin)        new_map.resolution = densmap.resolution        new_map.map_contour = densmap.map_contour                return new_map                  def blur_model(mol,resolution,emmap=False):        '''        calculates map from rd mol        '''                prot = MapTools._prepare_molmap_input(mol)        densmap = MapTools.gaussian_blur(prot, resolution, emmap)        return densmap        def _prepare_molmap_input(mol,n_conf = 0):          molmap_input = []     atm_coords = mol.GetConformers()[n_conf].GetPositions()     atom_props = mol.GetAtoms()          for coord,prop in zip(atm_coords,atom_props):         x = float(coord[0])         y = float(coord[1])         z = float(coord[2])         atm_type = prop.GetSymbol()         mass = float(prop.GetMass())         atom_input = [atm_type,x,y,z,mass]         molmap_input.append(atom_input)     return molmap_input        def gaussian_blur(prot,                      resolution,                      densMap,                      sigma_coeff=0.356,                      normalise=True):        newMap = densMap.copy()        newMap.density_map = np.zeros(densMap.box_size)                       sigma = sigma_coeff * resolution        newMap = MapTools.make_atom_overlay_map(newMap, prot)                         fou_map = fourier_gaussian(fftn(newMap.density_map), sigma)         newMap.density_map = np.real(ifftn(fou_map))        if normalise:            newMap.normalise()          return newMap             def make_atom_overlay_map(densMap, prot):               densMap = densMap.copy()        for atom in prot:            pos = MapTools.mapGridPosition(densMap, atom)            if pos:                densMap.density_map[pos[2]][pos[1]][pos[0]] += pos[3]                        return densMap     def mapGridPosition(densMap, atom):             origin = densMap.origin                apix = densMap.apix                box_size = densMap.box_size                x_pos = int(round((atom[1] - origin[0]) / apix[0], 0)) #change x        y_pos = int(round((atom[2] - origin[1]) / apix[1], 0))        z_pos = int(round((atom[3] - origin[2]) / apix[2], 0))                if(           (box_size[2] > x_pos >= 0) and           (box_size[1] > y_pos >= 0) and           (box_size[0] > z_pos >= 0)        ):            return x_pos, y_pos, z_pos, atom[4]        else:            return 0        def split_density(dmap, struct = None, label_threshold_sigma = None, label_threshold = None):                '''        Takes in a density map and creates a mask of disconnected densities         each with a differernt value starting from 1.                Threshold: only consider density values greater than thee threshold        struct: scipy.ndimage.label structure 3 * 3 array to define connected density        '''                           if struct == None:            struct = np.array([[[1,1,1],[1,1,1],[1,1,1]],[[1,1,1],[1,1,1],[1,1,1]],[[1,1,1],[1,1,1],[1,1,1]]])                masked_map = dmap.copy()                if label_threshold_sigma is not None:            threshold = MapTools.map_contour(dmap, t = label_threshold_sigma)                elif label_threshold is not None:            threshold  = label_threshold        else:            threshold = 0.0                masked_map.density_map = masked_map.density_map > threshold                labels, num_features = label(masked_map.density_map, structure = struct)        labeled_map = masked_map.copy()        labeled_map.density_map = labels                return masked_map, labeled_map, num_features        def map_contour(densmap, t = -1.0):        '''         Calculates map contour        '''                c1 = None        if t != -1.0:            zeropeak, ave, sigma1 = MapTools.peak_density(densmap)            if zeropeak is not None:                 c1 = zeropeak + (t * sigma1)            else:                c1 = 0.0               return c1            def peak_density(densmap):        freq, bins = np.histogram(densmap.density_map, 1000)        ind = np.nonzero(freq == np.amax(freq))[0]        peak = None        # Calculate average and standard deviation of the full data        ave, sigma = np.mean(densmap.density_map), np.std(densmap.density_map)        for i in ind:            val = (bins[i] + bins[i + 1]) / 2.            if val < float(ave) + float(sigma):                peak = val                if peak is None:            peak = ave                sigma1 = None        if peak is not None:            mask_array = densmap.density_map[densmap.density_map > peak]            sigma1 = np.sqrt(                np.mean(                    np.square(mask_array - peak)                )            )                return peak, ave, sigma1        def model_contour(p_map, t=-1.0):        '''        calculates model contour        '''        c2 = None            if t != -1.0:            c2 = t*p_map.std                return c2                            