import numpy as npimport mathimport osimport sysimport copyimport pickleimport astimport jsonimport warningsimport multiprocessingfrom dataclasses import dataclass, field import timefrom typing import Listfrom TEMPy.maps.map_parser import MapParserfrom ChemEM.parsers import Parsersfrom ChemEM.data_classes.data import  BasicDatafrom ChemEM.tools.system_tools import SystemToolsfrom ChemEM.tools.map_tools import MapToolsfrom ChemEM.tools.dock_tools import DockToolsfrom ChemEM.tools.rdtools import RDToolsfrom ChemEM.tools.openff_tools import  OpenFFToolsfrom ChemEM.scoring_functions import ScoringFunctionsclass System():    def __init__(self, system_id = None, system_data = None):                if system_id is None:            self.system_id = np.random.randint(100000)        else:            self.system_id = system_id                            if system_data is None:            self.system_data = BasicData()            self.__system_data_ref__ = id(self.system_data)        else:            self.system_data = system_data            self.__system_data_ref__ = id(self.system_data)                self.segments = {}        self.docking_jobs = {}                #map properties        self.maps = {}        self.map_contours = {}                #protein props        self.proteins = {} #maby make these lists!!        self.ligands = {}                #centroid data        self.centroid = []        self.segment_centroid = None        self.output = './'                #preprocessing data        self.auto_split_radius = 5.0        self.label_threshold = None         self.label_threshold_sigma = None                #exclude data        self.exclude = []        self.include_ligands_in_diff_map = 0        self.segment_dimensions = (30, 30, 30)        #fitting options        self.ligand_id = None        self.protein_id = None        self.difference_map_id = None        self.full_map_id = None        self.mi_weight = None         self.global_k = None         self.docking_radius = 15.0        self.platform = 'OpenCL'        self.cutoff = 15.0        self.flexible_side_chains = 0        self.solvent = False        #self.n_cpu = round(multiprocessing.cpu_count() / 2)        self.n_cpu = min(math.ceil(multiprocessing.cpu_count() / 2), 20)        self.n_ants = None        self.theta  = None        self.rho = None        self.sigma = None        self.max_iterations = None        self.generate_diverse_solutions = None                #post processing options        self.post_process_num_solutions = 10        self.post_process_solution = None        self.refine_side_chains = 1        self.cycles = 4        self.start_temp = 0        self.norm_temp = 300        self.top_temp = 315        self.temperature_step = 1        self.pressure = 1        self.barostatInterval = 10        self.initial_heating_interval = 10        self.heating_interval = 100        self.steps = 1000                                      #make setters for anything that uses and id!!    def __repr__(self):        return f'System(system_id={self.system_id}, num_proteins={len(self.proteins)}, num_ligands={len(self.proteins)}, num_maps={len(self.maps)})'        def copy(self):        return copy.deepcopy(self)        def save(self, file):                if not file.endswith('.chem'):            file += '.chem'                    with open(file, 'wb') as f:            pickle.dump(self, f)           @staticmethod    def load(file):        with open(file, 'rb') as f:            system = pickle.load(f)                SystemTools._update_system_data_ids(system)        SystemTools._update_protein_ids(system)        return system        def add_map(self, map_file, resolution,  map_contour= None, map_id = None, contour_level = 3.0):                if map_id is None:            map_id = f'M{len(self.maps)}'                        densmap = MapParser().readMRC(map_file)        densmap.map_id = map_id                if map_contour is not None:                        #self.map_contours[map_id] = map_contour            densmap.map_contour = map_contour                else:            #self.map_contours[map_id] = self.maps[map_id].std() * contour_level            #densmap.map_contour = densmap.std() * contour_level             densmap.map_contour = MapTools.map_contour(densmap, t=contour_level)                densmap.resolution = resolution                        self.maps[map_id] = densmap                return map_id        def get_map(self, map_id):                return self.maps[map_id]        def get_map_contour(self, map_id):                return self.maps[map_id].map_contour        def add_protein(self, protein_file, protein_id = None, outpath = None):                if protein_id is None:            protein_id = f'P{str(len(self.proteins))}'                self.proteins[protein_id] = Parsers.protein_parser(protein_file, protein_id, self.__system_data_ref__ )        return protein_id        def add_ligand(self, ligand_input,                    ligand_id = None ,                    input_type = 'smi',                   chain = "",                   residue_number = None):                if ligand_id is None:            ligand_id = f'L{str(len(self.ligands))}'                if residue_number is None:            residue_number = 0            for prot in self.proteins.values():                residue_number += prot.num_residues                        residue_number += len(self.ligands)                    self.ligands[ligand_id] = Parsers.ligand_parser(ligand_input,                                                        self.__system_data_ref__ ,                                                        ligand_id = ligand_id,                                                        chain = chain,                                                        residue_number = residue_number)                return ligand_id        def segment_system(self,centroid, box_dimensions, exclude = None):        #add exclude !!!                segment_id, segment  = SystemTools.segment_system(self, centroid, box_dimensions, exclude = exclude)                self.segments[segment_id] = segment        return segment_id        def score_ligand(self,                     binding_site_centroids,                     ligands,                     protein,                     difference_map =  None,                     full_map = None,                     mi_weight = None,                     radius = 15.0,#is this needed?                     cutoff = 15.0, #is this needed?                     out_path =  None):                if not is_iterable(ligands):            ligands = [ligands]                if not is_iterable( binding_site_centroids):            binding_site_centroids = [binding_site_centroids]                if difference_map is not None:            if not is_iterable(difference_map):                difference_map = [difference_map]                if difference_map is None:            if not len(ligands) == len(binding_site_centroids):                if len(binding_site_centroids) <= len(ligands):                    binding_site_centroids += [binding_site_centroids[0] for i in range(len(binding_site_centroids) , len(ligands))]                                else:                    warnings.warn(f'Num centroids ({len(binding_site_centroids)}) greater than num ligands ({len(ligands)}) for fitting', UserWarning)                    sys.exit()        else:                   if not len(ligands) == len(binding_site_centroids) == len(difference_map):                    if len(binding_site_centroids) <= len(ligands):                    binding_site_centroids += [binding_site_centroids[0] for i in range(len(binding_site_centroids) , len(ligands))]                                else:                    warnings.warn(f'Num centroids ({len(binding_site_centroids)}) greater than num ligands ({len(ligands)}) for fitting', UserWarning)                    sys.exit()                                if len(difference_map) <= len(ligands):                    difference_map += [difference_map[0] for i in range(len(difference_map), len(ligands))]                                else:                    warnings.warn(f'Num difference maps ({len(difference_map)}) greater than num ligands ({len(ligands)}) for fitting', UserWarning)                    sys.exit()                if mi_weight is None and difference_map is not None:            mi_weight = MapTools.get_mi_weight(full_map.resolution)                #TODO!! need to get this formated for multi ligand        rescore_ligands = [self.ligands[i] for i in ligands]        aco_object = SystemTools.dock_prep('rescore',                              [rescore_ligands[0]],                               self.proteins[protein],                              radius,                              binding_site_centroids,                              full_map,                              self.system_data,                              mi_weight = mi_weight,                              cutoff = cutoff,                                                            )                all_chemem_score = []        for lig in rescore_ligands:            chemem_score = ScoringFunctions.ChemEM_score([lig],aco_object,difference_map = difference_map  )            lig.chemem_score = chemem_score            line = f'{lig.lig_id} - {lig.residue_name} : {chemem_score}\n'            all_chemem_score.append(line)                    with open(out_path, 'w') as f:            f.writelines(all_chemem_score)                    def dock_ligand(self, binding_site_centroids,                    ligands,                     protein,                     difference_map = None,                    full_map = None,                    mi_weight = None, # get this fdrom resolution!!                    max_iterations = None,                    n_ants = None,                    theta  = None,                    rho = None,                    sigma = None,                    global_k = None,                    radius = 15.0,                    platform = 'OpenCL',                    cutoff = 15.0,                    flexible_side_chains = 0,                    solvent = False,                    n_cpu = None,                    post_process = True,                    out_path = None,                     generate_diverse_solutions = None                    ):                                        docking_id = f'F{len(self.docking_jobs)}'                       if n_cpu is None:            n_cpu = self.n_cpu                if generate_diverse_solutions is None:            generate_diverse_solutions = self.generate_diverse_solutions        if not is_iterable(ligands):            ligands = [ligands]                if not is_iterable( binding_site_centroids):            binding_site_centroids = [binding_site_centroids]                    if difference_map is not None:            if not is_iterable(difference_map):                difference_map = [difference_map]                 if difference_map is None:            if not len(ligands) == len(binding_site_centroids):                if len(binding_site_centroids) <= len(ligands):                    binding_site_centroids += [binding_site_centroids[0] for i in range(len(binding_site_centroids) , len(ligands))]                                else:                    warnings.warn(f'Num centroids ({len(binding_site_centroids)}) greater than num ligands ({len(ligands)}) for fitting', UserWarning)                    sys.exit()        else:                   if not len(ligands) == len(binding_site_centroids) == len(difference_map):                    if len(binding_site_centroids) <= len(ligands):                    binding_site_centroids += [binding_site_centroids[0] for i in range(len(binding_site_centroids) , len(ligands))]                                else:                    warnings.warn(f'Num centroids ({len(binding_site_centroids)}) greater than num ligands ({len(ligands)}) for fitting', UserWarning)                    sys.exit()                                if len(difference_map) <= len(ligands):                    difference_map += [difference_map[0] for i in range(len(difference_map), len(ligands))]                                else:                    warnings.warn(f'Num difference maps ({len(difference_map)}) greater than num ligands ({len(ligands)}) for fitting', UserWarning)                    sys.exit()                               for centroid, lig in zip(binding_site_centroids, ligands):            RDTools.translate_mol_to_centroid(self.ligands[lig], centroid)                                if mi_weight is None and difference_map is not None:            mi_weight = MapTools.get_mi_weight(full_map.resolution)                        #OpenMM protein!!!                t1 = time.perf_counter()                docking_run = SystemTools.dock_prep(docking_id,                              [self.ligands[i] for i in ligands],                               self.proteins[protein],                              radius,                              binding_site_centroids,                              full_map,                              self.system_data,                              platform = platform,                              mi_weight = mi_weight,                              global_k = global_k,                              cutoff = cutoff,                              flexible_side_chains = flexible_side_chains,                              solvent = solvent,                              n_cpu = n_cpu)                                if max_iterations is not None:            docking_run.max_iterations = max_iterations                if n_ants is not None:            docking_run.n_ants = n_ants                if theta is not None:            docking_run.theta = theta                 if rho is not None:            docking_run.rho = rho                 if sigma is not None:            docking_run.sigma = sigma                docking_run.generate_diverse_solutions = generate_diverse_solutions                       DockTools.ACO(docking_run, difference_map)        rt = time.perf_counter() - t1                out_file = []                #move most of this protein stuff to complex_system!!        protein_path = os.path.join(out_path, 'PDB')        mkdir(protein_path)               copy_of_coords = docking_run.complex_system.positions.copy()        if generate_diverse_solutions:            diverse, mapping, removed = self.get_diverse_solutions(docking_run.best_solutions, cutoff = generate_diverse_solutions )            docking_run.best_solutions = diverse + removed            #TODO!! write mapping!!!                                                for result in docking_run.best_solutions:            #result.write_chemem_solution(out_path)            result.write_refined_solution(out_path)            out_file.append(f'{result.iteration} :  {result.refined_score} \n')            protein_out = os.path.join(protein_path, f'Ligand_{result.iteration}.pdb')                        docking_run.complex_system.simulation.context.setPositions(result.protein_positions)                        OpenFFTools.write_complex_system(docking_run.complex_system.simulation.context.getState(getPositions=True).getPositions(),                                             docking_run.complex_system.simulation.topology,                                             protein_out,                                              missing_res = docking_run.protein._missing_residues)                docking_run.complex_system.simulation.context.setPositions(copy_of_coords)        of = os.path.join(out_path , 'results.txt')        with open(of, 'w') as f:            f.writelines(out_file)                docking_run._difference_map = difference_map        self.docking_jobs[docking_id] = docking_run        time_docking_out = os.path.join(out_path, 'times.txt')        time_docking_file = f'Docking runtime: {rt}'        with open(time_docking_out, 'w') as f:            f.write(time_docking_file)                                return docking_id        def get_diverse_solutions(self,solutions, cutoff = 2.0):        diverse = []        removed = []        mapping = {}        for sol in solutions:            for sol2 in diverse:                                rmsd = RDTools.diverse_rmsd(sol,sol2)                if rmsd <= cutoff:                    mapping[sol2.iteration].append(sol.iteration)                    removed.append(sol)                    break            else:                diverse.append(sol)                mapping[sol.iteration] = []                return diverse, mapping, removed                                                        def post_process_ligand(self,                             num_solutions = 10,                            refine_solutions = None,                            docking_job_id = None,                            global_k = None,                            out_path  = './',                            cycles = None,                            start_temp = None,                            norm_temp = None,                            top_temp = None,                            temperature_step = None,                            pressure = None,                            barostatInterval = None,                            initial_heating_interval = None,                            heating_interval = None,                            steps = None,                            ):                        if docking_job_id is None:            docking_job_id = list(self.docking_jobs.keys())[0]            docking_job = self.docking_jobs[docking_job_id]                            #map_bounds??        map_bounds = MapTools.get_map_bounds(docking_job._dens_map)                post_process_complex_system = OpenFFTools.openmm_complex_system(docking_job.protein,                                                                docking_job._ligand,                                                                docking_job._centroids,                                                                dens_map = docking_job._dens_map,                                                                map_bounds = map_bounds,                                                                global_k = global_k,                                                                cutoff= docking_job.binding_site_radius,                                                                flexible_side_chains = self.refine_side_chains,                                                                solvent = self.solvent,                                                                platform = self.platform)                        #if <param> is falsey: <param> = self.<param>        cycles = cycles or self.cycles        start_temp = start_temp or self.start_temp        norm_temp = norm_temp or self.norm_temp        top_temp = top_temp or self.top_temp        temperature_step = temperature_step or self.temperature_step        pressure = pressure or self.pressure        barostatInterval = barostatInterval or self.barostatInterval        initial_heating_interval = initial_heating_interval or self.initial_heating_interval        heating_interval = heating_interval or self.heating_interval        steps = steps or self.steps                all_post_processed_solutions = []                        if num_solutions > len(docking_job.best_solutions):            num_solutions = len(docking_job.best_solutions)                refine_solutions = [docking_job.best_solutions[i].iteration for i in range(num_solutions)]         all_times = []        if refine_solutions is None:            for num in range(num_solutions):                                if num > len(docking_job.best_solutions) - 1:                    break                                solution = docking_job.best_solutions[num]                out_file = os.path.join(out_path, f'Ligand_{solution.iteration}')                post_processed_solutions = OpenFFTools.simulated_anneling(post_process_complex_system,                                               solution,                                               missing_res = docking_job.protein._missing_residues,                                               out_file = out_file,                                               cycles = cycles,                                               start_temp = start_temp,                                               norm_temp = norm_temp,                                               temperature_step = temperature_step,                                               pressure = pressure,                                               barostatInterval = barostatInterval,                                               initial_heating_interval = initial_heating_interval,                                               heating_interval = heating_interval,                                               steps = steps,                                               aco_object = docking_job)                all_post_processed_solutions.append(post_processed_solutions)                                else:                for solution in docking_job.best_solutions:                if solution.iteration in refine_solutions:                                        out_file = os.path.join(out_path, f'Ligand_{solution.iteration}')                                        #make im here and then class postprocessing and then into openfftools and save/load !!                    t1 = time.perf_counter()                    post_processed_solutions = OpenFFTools.simulated_anneling(post_process_complex_system,                                                   solution,                                                   missing_res = docking_job.protein._missing_residues,                                                   out_file = out_file,                                                   cycles = cycles,                                                   start_temp = start_temp,                                                   norm_temp = norm_temp,                                                   temperature_step = temperature_step,                                                   pressure = pressure,                                                   barostatInterval = barostatInterval,                                                   initial_heating_interval = initial_heating_interval,                                                   heating_interval = heating_interval,                                                   steps = steps,                                                   aco_object = docking_job                                                   )                    rt = time.perf_counter() - t1                    all_times.append(f'{rt}\n')                    all_post_processed_solutions.append(post_processed_solutions)                results_out = os.path.join(out_path, 'results.txt')        results_file = []                for sol_group in all_post_processed_solutions:            results_file.append(f'{sol_group[0].ligand_id}\n')            for sol in sol_group:                results_file.append(f'\tCycle {sol.cycle} : {sol.chemem_score}\n')                                with open(results_out, 'w') as f:            f.writelines(results_file)                        times_out = os.path.join(out_path, 'times.txt')        with open(times_out, 'w') as f:            f.writelines(all_times)               def load_config(self, config_file):                config_object = Config()                with open(config_file, 'r') as f:            config_data = f.read().splitlines()            for line in config_data:                if line.startswith('#'):                    continue                else:                                        line = line.split('=')                    if len(line) < 2:                        continue                    else:                        print(line)                        #need to add logging and checks!!                        setattr(config_object, line[0].replace(' ', ''), line[1])        config_object.format_values()        return config_object                                class SystemFactory:        def __init__(self):        self.system = System()        self.map_ids = None        self.protein_ids = None        self.ligand_ids = None        self.pre_process = True        self.pre_process_split_density = False        self.fitting = True        self.post_processing = True        self.auto_split_point = None        self.auto_split_zone = None        self.preprocessing_options = None        self.dock_only = False        self.rescore = False            #zipped needs to be removed and replaced with options!    def add_ids(self, items, add_item_method, resolution = None, map_contour = None):                ids = []        if map_contour is not None:            if len(map_contour) == 0:                map_contour = None                for idx,item in enumerate(items):                       if not resolution is None and not map_contour is None :                id_ = add_item_method(item, resolution[idx], map_contour[idx])            elif not resolution is None and map_contour is None :                id_ = add_item_method(item, resolution[idx])            else:                                id_ = add_item_method(item)            ids.append(id_)        return ids        def create_system(self, config_object):                if config_object.load is None:                                   self.map_ids = self.add_ids(config_object.densmap, self.system.add_map, resolution = config_object.resolution, map_contour =  config_object.map_contour)            self.protein_ids = self.add_ids(config_object.protein, self.system.add_protein)                        if config_object.ligands_from_dir is not None:                config_object.ligand += self.get_ligands_from_dir(config_object.ligands_from_dir)                        self.ligand_ids = self.add_ids(config_object.ligand, self.system.add_ligand)        else:            self.system = System.load(config_object.load)                    # Set attributes from config object        for attr in ['pre_process', 'pre_process_split_density', 'auto_split_point', 'auto_split_zone',                      'fitting', 'dock_only','post_process', 'rescore', ]:                        setattr(self, attr, getattr(config_object, attr))                       system_attrs = ['centroid', 'segment_centroid', 'exclude', 'segment_dimensions', 'output', 'auto_split_radius',                        'ligand_id','difference_map_id', 'full_map_id','protein_id',                        'mi_weight', 'global_k', 'docking_radius', 'multiligand','platform', 'cutoff',                        'flexible_side_chains', 'solvent', 'n_cpu', 'label_threshold_sigma', 'label_threshold',                        'n_ants', 'theta',  'rho', 'sigma' , 'max_iterations',                         'post_process_num_solutions', 'post_process_solution', 'refine_side_chains',                        'cycles', 'start_temp', 'norm_temp', 'top_temp', 'temperature_step',                        'pressure', 'barostatInterval', 'initial_heating_interval',                        'heating_interval', 'steps', 'pdb_gt_id' , 'generate_diverse_solutions']        for attr in system_attrs:                                       value = getattr(config_object, attr, None)                        if value is not None:                setattr(self.system, attr, value)                #set up preprocessing options        self.system.centroid = [np.array(i) for i in config_object.centroid]        self.preprocessing_options = ['pre_process_split_density', 'auto_split_point', 'auto_split_zone']        self.preprocessing_options = [i for i in self.preprocessing_options if getattr(self, i)]       def get_ligands_from_dir(self, path):        return [os.path.join(path , i) for i in os.listdir(path) if i.endswith('.sdf') or i.endswith('.mol2')]        def make_run(self):                if self.pre_process:            preprocessing = Preprocessing(self.system, dock_only = self.dock_only)                        for option in self.preprocessing_options:                method_to_run = getattr(preprocessing, option)                method_to_run()                if self.fitting:                        if self.pre_process:                print(f'fitting to segment {preprocessing.segment_id}')                segment_id = preprocessing.segment_id                                    elif hasattr(self, 'segment_id'):                print(f'fitting to segment {self.segment_id}')                segment_id = self.segment_id                        elif len(self.system.segments) > 0:                    seg_ids = [key for key in self.system.segments]                    warnings.warn('No segment id given for fitting using segment {seg_ids[0]} from segments {seg_ids}, ', UserWarning)                    segment_id = seg_ids[0]            else:                warnings.warn('No segment id given for fitting and no system segments created', UserWarning)                sys.exit()            fitting = Fitting(self.system, segment_id, self.dock_only)                                            if self.post_process:                        print(self.post_process)            post_process = PostProcess(self.system)                if self.rescore:            if self.pre_process:                print(f'fitting to segment {preprocessing.segment_id}')                segment_id = preprocessing.segment_id                                    elif hasattr(self, 'segment_id'):                print(f'fitting to segment {self.segment_id}')                segment_id = self.segment_id                    elif len(self.system.segments) > 0:                    seg_ids = [key for key in self.system.segments]                    warnings.warn('No segment id given for fitting using segment {seg_ids[0]} from segments {seg_ids}, ', UserWarning)                    segment_id = seg_ids[0]            else:                warnings.warn('No segment id given for fitting and no system segments created', UserWarning)                sys.exit()                        rescore = Rescore(self.system, segment_id, self.dock_only)                                   class PostProcess:    def __init__(self, system):        self.system = system         self.set_up()        self.post_process()            def set_up(self):                self.out_path = os.path.join(self.system.output, 'post_processing')        mkdir(self.out_path)        self.num_soltuions = self.system.post_process_num_solutions                if len(self.system.post_process_solution) == 0:            self.process_solution = None        else:            self.process_solution = self.system.post_process_solution        def post_process(self):                        self.system.post_process_ligand(num_solutions = self.system.post_process_num_solutions,                                refine_solutions = self.process_solution,                                docking_job_id = None,                                global_k = self.system.global_k,                                out_path = self.out_path,                                cycles = self.system.cycles,                                start_temp =  self.system.start_temp,                                norm_temp = self.system.norm_temp,                                top_temp =  self.system.top_temp,                                temperature_step = self.system.temperature_step,                                pressure = self.system.pressure,                                barostatInterval = self.system.barostatInterval,                                initial_heating_interval = self.system.initial_heating_interval,                                heating_interval = self.system.heating_interval,                                steps = self.system.steps                                )        class Rescore:    def __init__(self, system, segment_id, dock_only = False):        self.system = system        self.segment_id = segment_id        self.dock_only = dock_only        self.set_up()        self.score()        def set_up(self):        #TODO this is the same as iin fitting make its own function!!        self.rescore_output = os.path.join(self.system.output, 'rescore.txt')        if self.system.ligand_id is None:            #rescore all ligands in system!            ligand_idxs_ids = [(num,key) for num, key in enumerate(self.system.ligands) if key not in self.system.exclude]            self.ligands = [i[1] for i in ligand_idxs_ids]            self.ligand_idxs =  [i[0] for i in ligand_idxs_ids]        else:            self.ligands = self.system.ligand_id                self.ligand_idxs = [list(self.system.ligands.keys()).index(i) for i in self.ligands]        self.centroid = [centroid for num, centroid in enumerate(self.system.centroid) if num in self.ligand_idxs]        if self.system.protein_id is None:            self.protein = [key for key in self.system.proteins if key not in self.system.exclude][0]            warnings.warn(f'No protein ID specified using first ID not in exclude : {self.protein}', UserWarning)        else:            self.protein = self.system.protein_id                    #full map if no map loaded will just do docking, need a way to specifiy docking!        if not self.dock_only:            if self.system.full_map_id is None:                                self.full_map = [self.system.segments[self.segment_id].maps[key] for key in self.system.segments[self.segment_id].maps if key not in self.system.exclude]                                if len(self.full_map) == 0:                    self.full_map = None                    warnings.warn('No full_map loaded running docking with no map!!!', UserWarning)                            else:                    self.full_map = self.full_map[0]                    warnings.warn(f'No full_map ID specified using first ID not in exclude : {self.full_map}', UserWarning)                        else:                self.full_map = self.system.segments[self.segment_id].maps[self.system.full_map_id ]                                    if self.system.difference_map_id is None:                self.difference_maps = [self.system.segments[self.segment_id].difference_maps[key] for key in self.system.segments[self.segment_id].difference_maps if key not in self.system.exclude]                if len(self.difference_maps) == 0:                    self.difference_maps = None                    warnings.warn('No diff_map loaded attempting docking with full map.', UserWarning)                    if self.full_map is not None:                        self.difference_maps = [self.full_map]                    else:                        self.difference_maps = None                        warnings.warn('No full_map loaded running docking with no map!!!', UserWarning)            else:                self.difference_maps = [self.system.segments[self.segment_id].difference_maps[key] for key in self.system.difference_map_id]                        else:            self.full_map = None            self.difference_maps = None            def score(self):                self.system.score_ligand(self.centroid,                                self.ligands,                                self.protein,                                difference_map =  self.difference_maps,                                full_map = self.full_map,                                mi_weight = self.system.mi_weight,                                radius = self.system.docking_radius,                                cutoff = self.system.cutoff,                                out_path =  self.rescore_output)                                        #self.save_system()        class Fitting:    def __init__(self, system, segment_id, dock_only = False):        self.system = system        self.segment_id = segment_id        self.dock_only = dock_only        self.set_up()        self.fit()        #self.save_system()            def set_up(self):                self.fitting_output = os.path.join(self.system.output, 'fitting')        mkdir(self.fitting_output)                if self.system.ligand_id is None:           ligand_idxs_ids = [(num,key) for num, key in enumerate(self.system.ligands) if key not in self.system.exclude]           self.ligands = [i[1] for i in ligand_idxs_ids]           self.ligand_idxs =  [i[0] for i in ligand_idxs_ids]                else:            self.ligands = self.system.ligand_id                self.ligand_idxs = [list(self.system.ligands.keys()).index(i) for i in self.ligands]                self.centroid = [centroid for num, centroid in enumerate(self.system.centroid) if num in self.ligand_idxs]                if self.system.protein_id is None:            self.protein = [key for key in self.system.proteins if key not in self.system.exclude][0]            warnings.warn(f'No protein ID specified using first ID not in exclude : {self.protein}', UserWarning)        else:            self.protein = self.system.protein_id                #full map if no map loaded will just do docking, need a way to specifiy docking!        if not self.dock_only:            if self.system.full_map_id is None:                                self.full_map = [self.system.segments[self.segment_id].maps[key] for key in self.system.segments[self.segment_id].maps if key not in self.system.exclude]                                if len(self.full_map) == 0:                    self.full_map = None                    warnings.warn('No full_map loaded running docking with no map!!!', UserWarning)                            else:                    self.full_map = self.full_map[0]                    warnings.warn(f'No full_map ID specified using first ID not in exclude : {self.full_map}', UserWarning)                        else:                self.full_map = self.system.segments[self.segment_id].maps[self.system.full_map_id ]                                    if self.system.difference_map_id is None:                                self.difference_maps = [self.system.segments[self.segment_id].difference_maps[key] for key in self.system.segments[self.segment_id].difference_maps if key not in self.system.exclude]                                                if len(self.difference_maps) == 0:                    self.difference_maps = None                    warnings.warn('No diff_map loaded attempting docking with full map.', UserWarning)                    if self.full_map is not None:                        self.difference_maps = [self.full_map]                    else:                        self.difference_maps = None                        warnings.warn('No full_map loaded running docking with no map!!!', UserWarning)            else:                                self.difference_maps = [self.system.segments[self.segment_id].difference_maps[key] for key in self.system.difference_map_id]                        else:            self.full_map = None            self.difference_maps = None                                def fit(self):                self.system.dock_ligand(self.centroid,                                self.ligands,                                self.protein,                                difference_map =  self.difference_maps,                                full_map = self.full_map,                                mi_weight = self.system.mi_weight,                                max_iterations = self.system.max_iterations,                                n_ants = self.system.n_ants,                                theta = self.system.theta,                                rho = self.system.rho,                                sigma = self.system.sigma,                                global_k = self.system.global_k,                                radius = self.system.docking_radius,                                platform = self.system.platform,                                 cutoff = self.system.cutoff,                                flexible_side_chains = self.system.flexible_side_chains,                                solvent = self.system.solvent,                                n_cpu = self.system.n_cpu,                                out_path =  self.fitting_output)                            def save_system(self):                out_file = os.path.join(self.system.output, f'System_{self.system.system_id}.chem')                for key in self.system.docking_jobs:            docking_job = self.system.docking_jobs[key]                                self.system.save(out_file)                                                    class Preprocessing:    def __init__(self, system, dock_only = False):        self.system = system        self.dock_only = dock_only        self.set_up()                    def set_up(self):        self.setup_centroid()        self.preprocessing_output = os.path.join(self.system.output, 'preprocessing')        mkdir(self.preprocessing_output)        self.setup_segment()        if not self.dock_only:            self.write_maps()    def setup_centroid(self):                try:            self.system.segment_centroid = self.system.centroid                            except IndexError:            warnings.warn('No centroid given for pre-processing', UserWarning)            sys.exit()    def setup_segment(self):        self.segment_id = self.system.segment_system(self.system.segment_centroid, self.system.segment_dimensions, exclude=self.system.exclude)                if not self.dock_only:            self.difference_map_id = self.system.segments[self.segment_id].make_difference_map(                proteins=list(self.system.proteins.keys()),                maps=list(self.system.maps.keys()),                ligands=list(self.system.ligands.keys()),                exclude=self.system.exclude,                inc_ligands=self.system.include_ligands_in_diff_map            )    def write_maps(self):        difference_map = self.system.segments[self.segment_id].difference_maps[self.difference_map_id]        difference_map.write_difference_map(            self.get_filepath(f'difference_map_{self.difference_map_id}.mrc')        )        difference_map.write_reverse_map(            self.get_filepath(f'difference_map_reverse_{self.difference_map_id}.mrc')        )        for key in self.system.segments[self.segment_id].maps:            map_file = self.get_filepath(f'full_map_{key}_segment_{self.segment_id}.mrc')            self.system.segments[self.segment_id].maps[key].write_to_MRC_file(map_file)            def get_filepath(self, filename):        return os.path.join(self.preprocessing_output, filename)    def pre_process_split_density(self):                self.mask_id = self.system.segments[self.segment_id].difference_maps[self.difference_map_id].split_density(label_threshold_sigma = self.system.label_threshold_sigma, label_threshold = self.system.label_threshold)        masks = self.system.segments[self.segment_id].difference_maps[self.difference_map_id].density_masks[self.mask_id]        masks.write_mask(self.get_filepath(f'difference_map_{self.difference_map_id}_split_density_{self.mask_id}.mrc'))    def auto_split_point(self):                masks = self.system.segments[self.segment_id].difference_maps[self.difference_map_id].density_masks[self.mask_id]                masks.get_closest_label(self.system.segment_centroid)        #HERE!!!         system_diffmap_ids = []        for out_num, num in enumerate(masks.features):            diffmap_copy = copy.deepcopy(self.system.segments[self.segment_id].difference_maps[self.difference_map_id])            diffmap_copy.difference_map.fullMap =  diffmap_copy.difference_map.fullMap * (masks.labeled_map.fullMap == num)            diff_map_id = f'D{len(self.system.segments[self.segment_id].difference_maps)}'            system_diffmap_ids.append(diff_map_id)            self.system.segments[self.segment_id].difference_maps[diff_map_id] = diffmap_copy            out_file = self.get_filepath(f'difference_map_{self.difference_map_id}_split_density_auto_point_{out_num}_{self.mask_id}.mrc')            diffmap_copy.write_difference_map(out_file)                        self.system.difference_map_id = system_diffmap_ids            def auto_split_zone(self):        masks = self.system.segments[self.segment_id].difference_maps[self.difference_map_id].density_masks[self.mask_id]                masks.get_zoned_label(self.system.segment_centroid, self.system.auto_split_radius)                        system_diffmap_ids = []                for out_num, num in enumerate(masks.features):            diffmap_copy = copy.deepcopy(self.system.segments[self.segment_id].difference_maps[self.difference_map_id])            diffmap_copy.difference_map.fullMap =  diffmap_copy.difference_map.fullMap * np.isin(masks.labeled_map.fullMap, num)            diff_map_id = f'D{len(self.system.segments[self.segment_id].difference_maps)}'            system_diffmap_ids.append(diff_map_id)            self.system.segments[self.segment_id].difference_maps[diff_map_id] = diffmap_copy            out_file = self.get_filepath(f'difference_map_{self.difference_map_id}_split_density_auto_zone_{out_num}_{self.mask_id}.mrc')            diffmap_copy.write_difference_map(out_file)        self.system.difference_map_id = system_diffmap_ids    def write_masked_difference_map(self):        difference_map = self.system.segments[self.segment_id].difference_maps[self.difference_map_id]        difference_map.write_difference_map(self.get_filepath(f'difference_map_masked_{self.difference_map_id}.mrc'))#put these somewhere!!!         def mkdir(path):    try:        os.mkdir(path)    except FileExistsError:        pass    def is_iterable(obj):    if isinstance(obj, str):        return False    try:        iter(obj)        return True    except TypeError:        return False    @dataclassclass Config:    pre_process : bool = field(default=True)    fitting : bool = field(default=True)    post_process : bool = field(default=True)    rescore : bool = field(default=False)    protein : List = field(default_factory=list)    ligand : List = field(default_factory=list)    densmap : List = field(default_factory=list)    resolution : List = field(default_factory=list)    centroid : List = field(default_factory=list)    output : str = field(default="./")    load = None    segment_centroid = None    map_contour : List = field(default_factory=list)    full_map_dimensions : List[int] = field(default=(30, 30, 30))    segment_dimesions : List[int] = field(default=(30, 30, 30))    exclude : List= field(default_factory=list)    ligands_from_dir : str = field(default=None)    difference_map_id : List = field(default_factory=list)    full_map_id : str = field(default=None)    platform : str = 'OpenCL'    cutoff : float = 20.0    flexible_side_chains : bool = field(default=False)    solvent : bool = field(default=False)    n_cpu : int =  None    post_process_solution : List = field(default_factory=list)        __list_ids__ = ['protein', 'ligand', 'densmap', 'resolution', 'centroid',                     'map_contour', 'exclude', 'difference_map_id', 'post_process_solution']    def _process_line(self, line):        line = line.split('=', maxsplit=1)        if len(line) < 2:            return        attr_id, value = line[0].strip(), line[1].strip()        try:            value = ast.literal_eval(value)        except:            pass                if attr_id in self.__list_ids__:            getattr(self, attr_id).append(value)                    else:            setattr(self, attr_id, value)                        print(f"{attr_id}, {value}, {type(value)}")    def load_config(self, config_file):        with open(config_file, 'r') as f:            for line in f:                if not line.startswith('#'):                    self._process_line(line.strip())                if not self.difference_map_id:            self.difference_map_id = None                if self.n_cpu is None:            cpus = round(multiprocessing.cpu_count() / 2)            if cpus > 20:                cpus = 20                        self.n_cpus = cpus                