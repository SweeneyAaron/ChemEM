# This file is part of the ChemEM software.## Copyright (c) 2023 - Topf Group & Leibniz Institute for Virology (LIV),# Hamburg, Germany.## This module was developed by:#   Aaron Sweeney    <aaron.sweeney AT cssb-hamburg.de>import timeimport numpy as npimport scipyfrom rdkit.Chem.rdmolops import Get3DDistanceMatrixfrom ChemEM.tools.rdtools import RDToolsfrom ChemEM.tools.math import MathToolsfrom ChemEM.tools.map_tools import MapToolsclass ScoringFunctions():        def ChemEM_score(mols, ACO_object, difference_map = None):                        t1 = time.perf_counter()        intra_vs1 = 0.0         intra_vs2 = 0.0        intra_vsteric = 0.0        n_atoms = 0                for ligand in mols:                        positions = ligand.GetConformer().GetPositions()                        ACO_object.distance_matrix.update_positions(positions, ACO_object.distance_matrix.protein_end_idx + n_atoms, set_matrix = False)            n_atoms += len(positions)            #score ligand intra            vs1, vs2, vsteric, = ScoringFunctions.get_ligand_intra_vdw(ligand)            intra_vs1 += vs1            intra_vs2 += vs2            intra_vsteric += vsteric        #update distance matrix                ACO_object.distance_matrix.set_distance_matrix()                        mol_hydrogens = [RDTools.rd_mol_hydrogens(mol) for mol in mols]        ACO_object.distance_matrix.update_mol_hydrogens(mol_hydrogens)                hbond_dist, hbond_angle, vina_g1, vina_g2, vina_s, hydrophobic = ScoringFunctions.interaction_scores(ACO_object)                        aromatic_dist, aromatic_angle = ScoringFunctions.aromatic_score(mols, ACO_object)                mi_score = 0.0                #move this to class!!!        score = sum([(hbond_dist * -0.07933760520000001),                      (hbond_angle * -0.041003613200000004),                      (vina_g1 * 0.008713077999999999),                      (vina_g2 * 0.00168411182),                      (vina_s * -0.08191086900000001),                      (hydrophobic * 0.007762313799999999),                      (aromatic_dist * -0.50855133),                      (aromatic_angle * 0.5343366),                      (intra_vs1 * -0.006212345479999999),                      (intra_vs2 * -0.00117344956),                      (intra_vsteric * -0.0168584281)]) + 3.4760564804077148                                if difference_map:            for dens_map, mol in zip(difference_map, mols):                                mi_score += ScoringFunctions.score_MI(mol, dens_map , dens_map.resolution )                        score += (mi_score * ACO_object.mi_weight)                        return score                else:            return score                def neadler_mead_local_search(solution,                                   score_func_params,                                   local_score_function,                                  _tol=1e1,  #1e-1                                   use_delta=None):                if not use_delta is None:            solution_delta = use_delta        else:            solution_delta = [2.0, 2.0, 2.0, 90.0, 90.0, 90.0] + \                [90.0 for i in range(6, len(solution))]                score_func_params['solution'] = solution                               result = scipy.optimize.minimize(local_score_function,                                 solution_delta,                                args = (score_func_params),method='Nelder-Mead', tol=_tol)#,                                #options={'adaptive' : True})                        new_score, new_mol, new_solution = local_score_function(result.x,                                                                 score_func_params,                                                                return_score_only = False)        del score_func_params['return_score_only']        del score_func_params['solution']                return new_score, new_mol, new_solution                        def  __chem_em_min_func_wrapper__(delta_solution,                                      score_function_params,                                       return_score_only = True):                new_solution = [i + j for i,j in zip(score_function_params['solution'],delta_solution)]        score_function_params['return_score_only'] =  return_score_only                if return_score_only:            score = ScoringFunctions.chemem_score(new_solution, score_function_params)            return score * -1#-100 # try give -1 score and tol 1e-1?        else:            score, mol = ScoringFunctions.chemem_score(new_solution, score_function_params)            return score, mol, new_solution                               def score_MI( mol : "RDkit Mol object" , map_slice : "TEMPy map instance", resolution : float ) -> float:                current_map = MapTools.blur_model(mol, resolution, emmap = map_slice)        mi = ScoringFunctions.calc_MI(map_slice, current_map)        return mi        def calc_MI(exp_map, sim_map, bins =20):        # Compute the 2D histogram        hist_2d, exp_boundaries, sim_boundaries = np.histogram2d(exp_map.density_map.ravel(), sim_map.density_map.ravel(), bins=bins)        # Convert histogram to joint probability distribution        joint_prob = hist_2d / np.sum(hist_2d)        # Compute marginal probabilities        exp_prob = np.sum(joint_prob, axis=1) #x        sim_prob = np.sum(joint_prob, axis=0)        # Outer product to get denominator for MI formula        outer = np.outer(exp_prob, sim_prob)        # Compute mutual information        joint_prob_nonzero = joint_prob[joint_prob > 0]  # Filter out zeros        outer_nonzero = outer[joint_prob > 0]  # Filter out corresponding values        MI = np.sum(joint_prob_nonzero * np.log2(joint_prob_nonzero / outer_nonzero))        return MI        def aromatic_score(mols, ACO_object):        aromatic_dist = 0.0        aromatic_angle = 0.0                ligand_rings = [RDTools.get_aromatic_rings(mol) for mol in mols]        for ligand_aromatic in ligand_rings:            for ring in ligand_aromatic:                for aromatic_resiude_key in ACO_object.protein_aromatic:                                        protein_rings = ACO_object.protein.get_residue(aromatic_resiude_key).aromatic_rings                    for protein_ring in protein_rings:                        dist = MathTools.euclidean_distance(ring.ring_center, protein_ring.ring_center)                        if dist <= ACO_object.system_data.chemdock.pipi_stack_dist_cutoff:                            angle = MathTools.get_plane_angle(ring.plane, protein_ring.plane)                            if angle > 90:                                angle =  90 - angle % 90                            if angle < 45:                                aromatic_angle += ScoringFunctions.score_aromatic_angle_lt_45(angle)                                aromatic_dist += ScoringFunctions.score_aromatic_dist_lt_45(dist)                            elif angle >= 45:                                aromatic_angle += ScoringFunctions.score_aromatic_angle_mt_45(angle)                                aromatic_dist += ScoringFunctions.score_aromatic_dist_mt_45(dist)               #this is just for multi ligand!!!        for num, ligand_1_rings in enumerate(ligand_rings[:-1]):            for ligand_aromatic_1 in ligand_1_rings:                                for ligand_2_rings in ligand_rings[num + 1:]:                    for ligand_aromatic_2 in ligand_2_rings:                        dist = MathTools.euclidean_distance(ligand_aromatic_1.ring_center, ligand_aromatic_2.ring_center)                                                if dist <= ACO_object.system_data.chemdock.pipi_stack_dist_cutoff:                            angle = MathTools.get_plane_angle(ligand_aromatic_1.plane, ligand_aromatic_2.plane)                                                        if angle > 90:                                angle =  90 - angle % 90                            if angle < 45:                                aromatic_angle += ScoringFunctions.score_aromatic_angle_lt_45(angle)                                aromatic_dist += ScoringFunctions.score_aromatic_dist_lt_45(dist)                            elif angle >= 45:                                aromatic_angle += ScoringFunctions.score_aromatic_angle_mt_45(angle)                                aromatic_dist += ScoringFunctions.score_aromatic_dist_mt_45(dist)                   return aromatic_dist, aromatic_angle        def interaction_scores(ACO_object):        #t1 = time.time() #remove after testing        dm = ACO_object.distance_matrix                hbond_dist = 0.0        hbond_angle = 0.0        vina_g1 = 0.0        vina_g2 = 0.0        vina_s = 0.0            hydrophobic = 0.0                interaction_cutoff = ACO_object.system_data.chemdock.interaction_cutoff                       for idx in range(dm.protein_end_idx, dm.num_atoms):                        atom_atom_distances = dm.distance_matrix[idx]            prot_idx = np.argwhere(atom_atom_distances <= interaction_cutoff)            mol_vdw_radii = RDTools.get_VDW_radii_by_symbol(dm.atom_elements[idx])                        for p_idx in prot_idx:                p_idx = p_idx[0]                if p_idx >= dm.protein_end_idx:                    continue                                protein_vdw_radii = RDTools.get_VDW_radii_by_symbol(dm.atom_elements[p_idx])                dij = atom_atom_distances[p_idx]                                vina_g1 += ScoringFunctions.vina_gauss_1(mol_vdw_radii, protein_vdw_radii, dij)                vina_g2 += ScoringFunctions.vina_gauss_2(mol_vdw_radii, protein_vdw_radii, dij)                vina_s += ScoringFunctions.vina_steric(mol_vdw_radii, protein_vdw_radii, dij)                                if dij <= 4.1:                    if (dm.donor_acceptor_hpi[idx][0] and dm.donor_acceptor_hpi[p_idx][1]) or (dm.donor_acceptor_hpi[idx][1] and dm.donor_acceptor_hpi[p_idx][0]):                        if len(dm.hydrogens[idx] + dm.hydrogens[p_idx]) > 0:                                                        hbond_dist += ScoringFunctions.get_hbond_dist(mol_vdw_radii, protein_vdw_radii, dij)                            hbond_angle += ScoringFunctions.score_angle_fast(dm.all_positions[idx],                                                                              dm.hydrogens[idx] + dm.hydrogens[p_idx],                                                                             dm.all_positions[p_idx])                                if dm.donor_acceptor_hpi[idx][2]:                    key = dm.reverse_position_keys[p_idx].split('.')                                        res_name = ACO_object.protein.get_residue(key[0]).residue_name                    hydrophobic += ScoringFunctions.get_hydrophobic_environment(res_name, key[1],ACO_object.system_data.chemdock.xlogp3_values)                                                    #TODO! ligand ligand interactions!!        atom_count = 0        for ligand_idx in range(ACO_object.n_ligands)[:-1]:            n_atoms = ACO_object.initial_mols[ligand_idx].GetNumAtoms()            start = dm.protein_end_idx + atom_count            end = start + n_atoms            atom_count += n_atoms                        for idx1 in range(start, end):                atom_atom_distances = dm.distance_matrix[idx]                lig_idx = np.argwhere(atom_atom_distances <= interaction_cutoff)                mol_vdw_radii = RDTools.get_VDW_radii_by_symbol(dm.atom_elements[idx])                for idx2 in lig_idx:                    idx2 = idx2[0]                    if idx2 < end:                        continue                                        protein_vdw_radii = RDTools.get_VDW_radii_by_symbol(dm.atom_elements[idx2])                    dij = atom_atom_distances[idx2]                                        vina_g1 += ScoringFunctions.vina_gauss_1(mol_vdw_radii, protein_vdw_radii, dij)                    vina_g2 += ScoringFunctions.vina_gauss_2(mol_vdw_radii, protein_vdw_radii, dij)                    vina_s += ScoringFunctions.vina_steric(mol_vdw_radii, protein_vdw_radii, dij)                                        if dij <= 4.1:                        if (dm.donor_acceptor_hpi[idx][0] and dm.donor_acceptor_hpi[idx2][1]) or (dm.donor_acceptor_hpi[idx][1] and dm.donor_acceptor_hpi[idx2][0]):                            hbond_dist += ScoringFunctions.get_hbond_dist(mol_vdw_radii, protein_vdw_radii, dij)                            hbond_angle += ScoringFunctions.score_angle_fast(dm.all_positions[idx],                                                                             dm.hydrogens[idx] + dm.hydrogens[idx2],                                                                            dm.all_positions[idx2])                        return hbond_dist, hbond_angle, vina_g1, vina_g2, vina_s, hydrophobic                def score_aromatic_dist_lt_45(x: float) -> float:            """        Exponnorm dist        when angle <= 45 degree            """                params = (8.676871348763687, 3.5249017377045195, 0.15811309742560023)        value = scipy.stats.exponnorm.pdf([x],*params)        return value[0]        def score_aromatic_angle_lt_45(x: float) -> float:                """        beta dist        when angle <= 45 degree            """        params = (0.8474822516592184, 1.1225727681379172, 5.029999999999999, 40.72930022146549)        if x <= 5.5 and x >= 0.0:            return 0.5        else:                        values = scipy.stats.beta.pdf([x], *params)            return values[0] * 10            def score_aromatic_dist_mt_45(x: float) -> float:                """        skewnorm dist        when angle <= 45 degree            """        params = (9.053180063364891, 4.439198454035568, 1.529438444586496)        value = scipy.stats.skewnorm.pdf([x],*params)        return value[0]            def score_aromatic_angle_mt_45(x:float) -> float:                """        beta dist        when angle >= 45 degree            """        params = (1.1243674838365876, 0.8073831243054279, 45.00511368027688, 44.984886319723124)                if x >= 85 and x <= 90:            return 0.5                else:            values = scipy.stats.beta.pdf([x], *params)            return values[0] * 10               def get_hydrophobic_environment(res_name : str, atom_id : str, interactions_data  : "interactions_data object") -> float:        nts = ['DA','DC','DG','DT']        ions = ['MG']        if res_name in nts or res_name in ions:            return 0.0                if atom_id == 'OXT':            atom_id = 'O'        try:            return interactions_data[res_name][atom_id]        except:            return 0.0        def score_angle_fast(donor_atom, hydrogens, acceptor_atom):              angle =  max([ MathTools.calc_bond_angle(donor_atom, hydrogen, acceptor_atom) for hydrogen in hydrogens])        return ScoringFunctions.get_hbond_angle(angle)           def get_hbond_angle(angle: float) -> float:                return 0.0 + ((angle) / (180.0) * (1.0 - 0.0))        def get_hbond_dist(ri : float ,rj : float ,dij : float ) -> float:                d = dij - ri - rj        if d <= -0.7:            return -1        elif d >= 0.0:            return 0        else:            return (d / - 0.7) * -1            def get_ligand_intra_vdw(mol ):        matrix = Get3DDistanceMatrix(mol)                intra_vs1 = 0.0        intra_vs2 = 0.0        intra_vsteric = 0.0                hydrogen_indexes = [i.GetIdx() for i in mol.GetAtoms() if i.GetSymbol() == 'H']                for index, dist in enumerate(matrix):            atom =  mol.GetAtomWithIdx(index)            if atom.GetSymbol == 'H':                continue            else:                excluded_index =  ScoringFunctions.get_intra_exclusion(atom)                for index2, dist in zip( range( index+1, len(matrix[0]) ) , matrix[index][index+1:] ):                    if index2 in excluded_index or index2 in  hydrogen_indexes:                        continue                    else:                        ri = RDTools.get_VDW_radii(atom)                        rj = RDTools.get_VDW_radii(mol.GetAtomWithIdx(index2))                                                                        intra_vs1 += ScoringFunctions.vina_gauss_1(ri, rj, dist)                        intra_vs2 += ScoringFunctions.vina_gauss_2(ri, rj, dist)                        intra_vsteric += ScoringFunctions.vina_steric(ri, rj, dist)                                        return  intra_vs1, intra_vs2, intra_vsteric            def get_intra_exclusion(atom):            exclusion_indexes = []        atom_neighbors = atom.GetNeighbors()        for ni in atom_neighbors:            idx = ni.GetIdx()            if idx not in  exclusion_indexes:                 exclusion_indexes.append(idx)            ni_neighbors = ni.GetNeighbors()            for ni_ni in ni_neighbors:                idx = ni_ni.GetIdx()                if idx not in  exclusion_indexes:                    exclusion_indexes.append(idx)        return exclusion_indexes        def vina_gauss_1(ri : float , rj : float , dij : float) -> float:        d = dij - ri - rj        return np.exp(-(d/0.5)**2)        def vina_gauss_2(ri : float , rj : float , dij : float ) -> float:        d = dij - ri - rj        return np.exp(-((d-3)/2)**2)        def vina_steric(ri : float ,rj : float ,dij : float) -> float:        d= dij - ri - rj        if d < 0:            return d ** 2        else:            return 0.0                    