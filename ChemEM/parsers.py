# This file is part of the ChemEM software.## Copyright (c) 2023 - Topf Group & Leibniz Institute for Virology (LIV),# Hamburg, Germany.## This module was developed by:#   Aaron Sweeney    <aaron.sweeney AT cssb-hamburg.de>from ChemEM.tools.openff_tools import OpenFFToolsfrom ChemEM.tools.rdtools import RDToolsfrom ChemEM.data_classes.protein import Protein, Residuefrom ChemEM.data_classes.ligand import Ligandfrom ChemEM.data_classes.base_classes import Atomfrom ChemEM.data_classes.EMMap import EMMapfrom rdkit import Chemimport ctypesimport numpy as npimport mrcfileimport sysclass Parsers():    def protein_parser(protein_file, protein_id, base_data_ref, forcefield = []):                protein = Protein(protein_file = protein_file, protein_id = protein_id, __base_data__ = base_data_ref)        _chem_em_residue_data , receptor_structure, _openff_chemem_conversion_keys, _chemem_conversion_keys, _missing_residues = OpenFFTools.load_protein_structure(protein_file, forcefield = forcefield)                                  protein.openff_structure = receptor_structure        protein.num_residues = len(_chem_em_residue_data)        protein_residues = []        _protein_ref = id(protein)        _residues = {}                                for num, res in enumerate(_chem_em_residue_data):            residue = Residue(residue_name = res['name'],                              residue_number = res['number'],                              chain = res['chain'],                              residue_key = res['key'],                              __rdmol__ = res['mol'],                              __prot_ref__ = _protein_ref)                        _residues[res['key']] = num            positions = residue.GetConformer().GetPositions()            residue_atoms = []            base_data = ctypes.cast(base_data_ref, ctypes.py_object).value                        for atom_id, atom_idx in res['atom_indexs'].items():                            atom = Atom(atom_name = atom_id,                            element = residue.GetAtomWithIdx(atom_idx).GetSymbol(),                            coords = positions[atom_idx],                            idx = atom_idx,                            hydrogens = res['hydrogens'][atom_id],                            donor_potential = len(res['hydrogens'][atom_id]),                            acceptor_potential = Parsers.get_lone_pair_data(residue.GetAtomWithIdx(atom_idx).GetSymbol(), base_data),                            )                residue_atoms.append(atom)                        residue.atoms = residue_atoms            residue.__atoms__ = res['atom_indexs']            protein_residues.append(residue)                protein.residues = protein_residues        protein.__openff_conversion_keys__ = _openff_chemem_conversion_keys        protein.__chemem_conversion_keys__ = _chemem_conversion_keys        protein.__residues__ = _residues        protein._missing_residues = _missing_residues                return protein        def get_lone_pair_data(element, base_data):                try:            lone_pairs = base_data.atom_lone_pair_data[element]            return lone_pairs        except KeyError:            return 0            def ligand_parser(ligand_input,                       base_data_ref,                      ligand_id = None,                      chain = None,                      input_type = 'smi',                       residue_number = 0,                      protonation = True,                      chirality=True,                      rings=True,                      pH=[6.4, 8.4],                      n=1.0):                input_types = ['smi', 'sdf', 'mol2']                base_data = ctypes.cast(base_data_ref, ctypes.py_object).value        rd_mol = None        exceptions = []                                        for lig_type in input_types:            try:                rd_mol = RDTools.get_rd_mol(ligand_input,                                            lig_type,                                             protonation = protonation,                                            chirality=chirality,                                            rings=rings,                                            pH=pH,                                            n=n                                            )                if rd_mol is not None:                    break            except Exception as e:                exceptions.append(e)                        if rd_mol is None:            #TODO! add FatalERROR            print('ChemEM Fatal Error: Could not read molecule input: {ligand_input}')            for num, e in enumerate(exceptions):                print(f'Attempted reading by {input_types[num]}. Failed with Error:')                print(f'\t{e}')            sys.exit()                #RDMOL IS NOW A LIST OF MOLS!!        if ligand_id is None:            ligand_id =  str(np.random.randint(100000))        openff_structure = OpenFFTools.load_ligand_structure(rd_mol)                ligand = Ligand(rd_mol,                         name = ligand_id,                        chain = chain,                        residue_number = residue_number,                        lig_id = ligand_input)                ligand.openff_structure = openff_structure                atoms = Parsers.get_ligand_atoms(rd_mol, base_data)                ligand.atoms = atoms                return ligand    def get_ligand_atoms(molecule, base_data):                positions = molecule.GetConformer().GetPositions()        atoms = []        _ids = {}        _hydrogens = RDTools.get_mol_hydrogens(molecule)                for idx, coord in enumerate(positions):            element = molecule.GetAtomWithIdx(idx).GetSymbol()                        if element not in _ids:                atom_id = f'{element}{1}'                _ids[element] = 1                        else:                _ids[element] += 1                atom_id = f'{element}{_ids[element]}'                        coords = positions[idx]            hydrogens = _hydrogens[idx]            donor_potential = len(hydrogens)            atom = Atom(atom_name = atom_id,                        element = element,                        coords = coords,                        idx = idx,                        hydrogens = hydrogens,                        donor_potential =  donor_potential,                        acceptor_potential = Parsers.get_lone_pair_data(element, base_data))            atoms.append(atom)        return atoms    def map_parser(map_file, resolution,  map_contour = None):                        with mrcfile.open(map_file, permissive=True) as mrc:            mrc_data = mrc.data             mrc_header = mrc.header                        apix = np.array([mrc.voxel_size.x,                             mrc.voxel_size.y,                            mrc.voxel_size.z])                                   origin = np.array([mrc_header.origin.x,                               mrc_header.origin.y,                               mrc_header.origin.z])                                    if np.all(origin) == 0:                origin_idx = np.array([mrc_header.nxstart,                                       mrc_header.nystart,                                       mrc_header.nzstart])                origin = origin_idx * apix                            mrc_data = mrc_data.astype(np.float64, copy=False)                                    current_order = list(np.array([mrc_header.mapc, mrc_header.mapr, mrc_header.maps]))            transpose_indices = [current_order.index(axis) for axis in [1,2,3]]            data = np.transpose(mrc_data, axes=transpose_indices)            apix = np.array([apix[i] for i in transpose_indices])            origin = np.array([origin[i] for i in transpose_indices])                        densmap = EMMap(origin,                            apix,                            data,                            resolution)                        densmap.ispg = mrc_header.ispg             densmap.extra1 = mrc_header.extra1             densmap.extra2 = mrc_header.extra2                     densmap.exttyp =  mrc_header.exttyp            densmap.extended_header = mrc.extended_header                        if map_contour is None:                densmap.set_map_contour()                        densmap.resolution = resolution                        return densmap                                                                                   